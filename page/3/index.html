<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hex Fantastic</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Rayer&apos;s personal code logs">
<meta property="og:type" content="website">
<meta property="og:title" content="Hex Fantastic">
<meta property="og:url" content="https://rayer.github.com/page/3/index.html">
<meta property="og:site_name" content="Hex Fantastic">
<meta property="og:description" content="Rayer&apos;s personal code logs">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hex Fantastic">
<meta name="twitter:description" content="Rayer&apos;s personal code logs">
  
    <link rel="alternate" href="/atom.xml" title="Hex Fantastic" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hex Fantastic</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">這世界有點無聊，找點架吵吧!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rayer.github.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-talking-about-the-c-11-lambda" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/17/talking-about-the-c-11-lambda/" class="article-date">
  <time datetime="2014-01-16T22:39:00.000Z" itemprop="datePublished">2014-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/17/talking-about-the-c-11-lambda/">淺談C++11 Lambda (1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#披荊斬棘的史前時代</p>
<p>Lambda在很多語言中有著相當的地位，不過相似的工具一直在C++11以前都付之闋如，而必須用傳入函數指標的方式來達成類似的效果 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//這種寫法我們稱為C-Stype</div><div class="line">typedef int(*compare)(void*, void*);</div><div class="line">void sort(void** sortingObjects, int length, compare comparer);</div></pre></td></tr></table></figure></p>
<p>這種寫法其實剛好踩在清楚不清楚的邊緣，而且說真的這種void*亂轉看起來也不太靠譜，所以後來大家在C++就改成用template來完成類似的東西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//這個其實是編譯不過去的....</div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">int compare(const CmpObj&amp; Obj1, const CmpObj&amp; Obj2);</div><div class="line"></div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">void sort(const CmpObj* objList, int length, compare&lt;CmpObj&gt; comparer);</div></pre></td></tr></table></figure>
<p>但是typedef其實這舊時代產物是不吃template的（這原因頗長，不過可以想想其實typedef原始目的根本不是拿來定義跟簡化函數指標），所以要不就是用C++11的using關鍵字，要不就是用很類似java的workaround</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//C++11 only</div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">using compare = int (*) (const CmpObj&amp; obj1, const CmpObj&amp; obj2); </div><div class="line"></div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">void sort(const CmpObj* objList, int length, compare&lt;CmpObj&gt; comparer);</div><div class="line"></div><div class="line">//如果想要長得像Java的話...</div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">struct ComparerStr &#123;</div><div class="line">	//這static很重要 少了它就沒辦法ComparerStr&lt;CmpObj&gt;::compare了</div><div class="line">  //當然你要new一個我也不反對，只是這種東西多半是static，不管是new一個還是丟實體進去意義都差不多</div><div class="line">  //new的話還額外多了一個delete的成本跟風險。</div><div class="line">	static int compare(const CmpObj&amp; obj1, const CmpObj&amp; obj2);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//裡面就可以直接取cmp::compare,我就不多寫實做怎麼做了</div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">void sort(const CmpObj* objList, int length, ComparerStr&lt;CmpObj&gt; cmp);</div></pre></td></tr></table></figure>
<p>在還沒有C++11 using的年頭，很顯然的要不就是學這種類java的做法丟class進去，要不就是用很恐怖的函數指標方式來處理這種問題。除了C Programmer以外，我想應該不會有太多正常人喜歡用函數指標，於是大家就開始使用boost::function以及旗下一大套東西來「表達」一個function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boost::function&lt;int(void*, void*)&gt; comparer;</div></pre></td></tr></table></figure>
<p>但是很不幸的是，雖然C++提供template的技術，卻沒辦法讓你產生一個「template化的template」，所以事實上boost的做法並沒有辦法讓你提供comparer用的型別。</p>
<p>上面的做法其實都有兩個很類似的問題，其中後者是相依于前者的，也就是：</p>
<ul>
<li>我必須把一個僅僅使用一次的comparer額外定義在一個很遙遠的地方，然後才能引用他，而非「他被用到的地方」</li>
<li>要是這個comparer還需要根據一個外部變數來工作，那就死了</li>
</ul>
<p>#後來參戰的Obj-C<br>然後Obj-C開始有類似的技術 叫做Block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//由於id可以吃任何東西，以及由於obj-c語言特性，這個其實連template都用不上</div><div class="line">typedef int* (^comparer_block)(id, id);</div><div class="line">-(void) sort:(NSArray*) objects andComparer:(comparer_block) comparer;</div></pre></td></tr></table></figure></p>
<p>這個我們就不深究了，畢竟這邊以C++ lambda為主。不過請記住， <strong>其實Obj-C的block就是Lambda</strong> </p>
<p>#C++11終於出現的Lambda</p>
<p>我們先拿一個簡單的東西作例子，就拿Bjarne Stroustrup自家的C++11 FAQ舉的例子吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//預設的sort法</div><div class="line">std::sort(v.begin(), v.end());</div><div class="line">//用我們自己決定的comparer來sort</div><div class="line">std::sort(v.begin(), v.end(), [](int a, int b) &#123; return abs(a)&lt;abs(b); &#125;);</div></pre></td></tr></table></figure>
<p>這邊定義了一個新的sort方法，用新的Comparer來定義Sort的順序，從以default改為絕對值。在我們搞清楚怎麼把lambda寫入函式簽名以前，我們先看看這語法上代表的什麼意義</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//-&gt;bool是可以省略的，這個相當於指定回傳型別</div><div class="line">[](int a, int b)-&gt;bool &#123; return abs(a) &lt; abs(b);&#125;</div></pre></td></tr></table></figure>
<p>這邊一共分三個部分，[]等等會提到是什麼意思，而且在這例子裡面其實並沒有用到。中間則是很明顯的他需要兩個參數，都是int，而且是pass by value，最後則是隱式的傳回bool，沒有在裡面宣告。</p>
<p>接下來的問題就是，如果我們要求一個特定簽名的lambda，那這個要怎麼寫？以前的函數指標可能可以寫成這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef int(*CMP)(void*, void*);</div><div class="line">//然後我們可以要求下面兩種之一的寫法</div><div class="line">void sort(void* itemArray, int length, int(*CMP)(void*, void*));</div><div class="line">void sort(void* itemArray, int length, CMP cmp);</div></pre></td></tr></table></figure></p>
<p>在C++11要使用Lambda的場合則是用C++11新的std::function來當作參數來傳遞。另外，雖然上面提到的code很多明明有用到C++11卻可以再沒有–std=c++11的flag下編譯過關， <strong><em>可是下面這組code沒–std=c++11會死，請把它加入g++的參數裡面</em></strong> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//這也沒有真正的sort 說說而已 XD</div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">void sort(std::vector&lt;CmpObj&gt; objList, std::function&lt;int(CmpObj&amp;, CmpObj&amp;)&gt; func) &#123;</div><div class="line">	CmpObj a, b;</div><div class="line">	a = objList[0];</div><div class="line">	b = objList[1];</div><div class="line">	printf(&quot;return : %d&quot;, func(a, b));</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">	int a = 1;</div><div class="line">	int b = 2;</div><div class="line">	std::vector&lt;int&gt; list;</div><div class="line">	list.push_back(a);</div><div class="line">	list.push_back(b);</div><div class="line">  //這個&lt;int&gt;恐怕免不了，g++似乎無法正確推導lambda裡面的template parameter</div><div class="line">	sort&lt;int&gt;(list, [](int x, int y)&#123; printf(&quot;%d, %d\n&quot;, x, y); return 1;&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，這邊先淺嚐即止，剩下的我們留到下一篇討論。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/17/talking-about-the-c-11-lambda/" data-id="cj3bltoo3000es3siubjxu0wm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-no-modern-design-modern-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/15/no-modern-design-modern-c/" class="article-date">
  <time datetime="2014-01-14T23:42:00.000Z" itemprop="datePublished">2014-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/15/no-modern-design-modern-c/">不再Modern的Modern C++ Design... :)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>寫在前面，我沒有任何貶低這本書的意思。這本書畢竟已經十幾年了，但是仍然是在C++技術領域中的經典之作。不過，在C++11出現的現在，這本在一些地方顯然是有點過時，所以每當我發現裡面有一些目前C++11已經可以cover掉的tech，我會在這裡做些補充。</p>
<p>##STATIC_CHECK (replaced by C++11 static_assert() )<br>會發現這個其實是有點意外，因為這東西其實不太容易發現。我們先看看Loki版本的STATIC_CHECK長什麼樣子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_CHECK(expr) &#123; char unnamed[(expr) ? 1 : 0]; &#125;</span></div></pre></td></tr></table></figure></p>
<p>這個容許你能夠在編譯期檢查一些東西。這東西建立在一個前提下：char[1]是可以合法編譯過關，而char[0]則會造成編譯錯誤，所以他有能力在compile time檢查硬生生的把compiling過程擋下來。以Modern C++ Design自己舉的例子來講<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TO, <span class="keyword">typename</span> FROM&gt;</div><div class="line"><span class="function">TO <span class="title">safe_reinterpret_cast</span><span class="params">(FROM from)</span> </span>&#123;</div><div class="line">        STATIC_CHECK(<span class="keyword">sizeof</span>(TO) &gt;= <span class="keyword">sizeof</span>(FROM));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;TO&gt;(from);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>這個template其實極其簡單，就是如果你試圖把FROM轉成TO，他會先檢查TO是否是個足夠大，至少要足以容納FROM的大小，簡單的說，假設你的TO是char，FROM是double，他就會invoke出STATIC_CHECK，讓STATIC_CHECK編譯錯誤，因為試圖做一個char array大小為0。</p>
<p>不過這段Code因為規格變更，有 <strong>很多</strong> 地方不再正確，我們一個個的看一下。</p>
<p>首先，你會發現char[0]其實已經在C99合法化了，至於[0]的用途請參照<a href="http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html" target="_blank" rel="external">這裡</a>，所以char[0]不再會造成編譯錯誤。另外，reinterpret_cast在C++11下已經會做出大小的檢查，已經不再允許把大的資料結構硬轉成小的資料結構了。</p>
<p>最後一點，也是最重要的是，C++11引入了<code>static_assert(bool willAssert, const char* assertMessage)</code>，使得這種做法不再必要。不過，我們有很多舊有的code，該怎麼辦呢？</p>
<p>在不支援C++11(但是因為C99所以可以合法宣告0長度array的場合)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//既然0不會報錯，-1總會死了吧？</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_CHECK(expr) &#123; char unnamed[(expr) ? 1 : -1]; &#125;</span></div></pre></td></tr></table></figure></p>
<p>支援C++11的場合<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_CHECK(expr) &#123; static_assert(expr, <span class="meta-string">"Static Assert is invoked!"</span>); &#125;</span></div></pre></td></tr></table></figure></p>
<p>當然，新的code請都用static_assert來取代STATIC_CHECK</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/15/no-modern-design-modern-c/" data-id="cj3bltony000bs3sijzz6b7xw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-talk-about-why-mac-gradually-eating-away-at-pc-market" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/15/talk-about-why-mac-gradually-eating-away-at-pc-market/" class="article-date">
  <time datetime="2014-01-14T20:52:00.000Z" itemprop="datePublished">2014-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/15/talk-about-why-mac-gradually-eating-away-at-pc-market/">聊聊Mac為什麼逐漸蠶食PC市場</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前幾天看到一篇文章，北美市場Mac增長25%+，同時間PC市場卻大幅萎縮。Mac跟PC的大戰也打了二十年了，PC始終無法徹底消滅掉Mac，當然Mac有相當多優越的地方，讓我們看看這次此消彼長的轉捩點。</p>
<ul>
<li>大約是在4-5年前，MBP有一波相當大的降價，大約台灣售價從九萬多變成七萬多(17”)，從此MBP不再是超高價的選擇，價格開始跟高階筆電差不多。</li>
<li>第二代MBA的推出以及價格，這個我想是最大的轉捩點。第一代的MBA根本是個問題產品，直到第二代推出以後，價格跟當時超薄的厚度重量以及不錯的手工藝外觀，使得MBA開始為消費市場大量接受(即使當年推出的連core i都還不是，僅僅只是C2D)。說到MAC佔有率的上昇，第二世代的MBA真的功不可沒，也強迫PC陣營弄出個叫做Ultrabook的商業名詞，這波PC陣營在netbook領先的部分，幾乎是被瞬間追平。</li>
<li>Magic Trackpad的推出，把MacBook的體驗完全徹底複製到了iMac上。</li>
<li>平板的興起間接造成OpenGL的興盛以及DX的衰退。</li>
</ul>
<p>雖然我也不知道這是不是Apple的策略，不過顯然從MBA開始的MacBook產線，算是相當程度地打開了OSX的市場，而也一定程度的讓更多人願意使用看看iMac – 而有一個小產品也一定程度的幫助了iMac的銷售，就是Magic Trackpad。雖然這場大戰看起來Mac算是在順風側，不過，誰知道呢 =P 也許哪天PC也會來個驚人的發想，也說不一定，畢竟現在整體仍然是站在PC這端的。</p>
<p>還有一件小事情對PC也是挺不利的 – 就是DirectX開發的沒落。目前來講，許多的遊戲成像引擎仍然支援OpenGL跟DX，但是相當多的遊戲開發商已經傾向于使用Wrapper – 比方說Unity – 而不是直接使用DX或者僅限於DX的引擎。當然目前來講，高端成像引擎如Crysis, GameByro仍然主流支援DX，但是在移植到平板簡單的誘因下，我想採用Wrapper甚至直接用OpenGL開發會越來越多，而這正是PC的痛處 – 支援DX可是別無分號，只有Windows可以做的到。DX跟OpenGL的戰爭也打了10年了，DX曾經贏到幾乎把OpenGL打到一無是處(感謝Khronos努力地守住最後一塊陣地，終於在平板成為主流以後努力開花結果)，而這幾年看來DX卻停滯在11，而且沒辦法在大多數平板上跑。採用OpenGL的意思就是，我們可以很合理的期待mac也能玩(撒花)，這也是許多人的軟肋 – 因為很多遊戲只能在Windows上跑。</p>
<p>這場大戰，Mac慢慢地占了上風，只是離扳平還有很長的一段路要走啊，而且價格也是一個很難彌補的gap。這場大戰，讓我們繼續看下去…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/15/talk-about-why-mac-gradually-eating-away-at-pc-market/" data-id="cj3bltoo0000cs3sisqv0agd3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-talking-about-the-four-c-style-casting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/08/talking-about-the-four-c-style-casting/" class="article-date">
  <time datetime="2014-01-07T23:53:00.000Z" itemprop="datePublished">2014-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/08/talking-about-the-four-c-style-casting/">淺談C++ Style的四種casting</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>這四個的名稱應該大家都很熟了，包含了static_cast, dynamic_cast, const_cast跟reinterpret_cast。不過，這些cast其實或多或少都有一些隱藏的灰色地帶，在這篇文章，我們試圖來看看這四種cast分別有什麼不容易被普通PG看到的地方。</p>
<p>附錄：還有一個駭人聽聞的規格外的東西叫做boost::lexical_cast, 這東西我們晚點聊一下。</p>
<p>##static_cast<br><code>static_cast&lt;Ty&gt;</code>是一個最常見的轉型法，這個轉型其實代表的背後意義是「編譯器被允許做的隱式轉型，void<em>間的互轉，以及non-runetime下安全的子轉父」，任何超出這個範疇的都會直接被編譯器擋下來，包含`int</em><code>轉</code>char<em>`這種行為，都會被擋下。編譯器會自動幫你做的隱式轉換包含了像是int幫你轉成double等等(也就是當你用explicit關鍵字的時候想要編譯器避免的行為)，void</em>互轉是特例，任何東西都能轉成void<em>而void</em>也能轉成任何東西(我一直認為這條規則是為了相容性而存在的)，以及比如<code>class B : public A</code>下允許<code>A* a = static_cast&lt;A*&gt;(new B());</code>這種轉法(但是並不允許相反的<code>B* b = static_cast&lt;B*&gt;(new A());</code>)。</p>
<p>如果你很有把握你沒搞出太大致命的錯誤的話，由於少了很耗資源的RTTI檢查，理論上這種轉法會比dynamic_cast快上非常多。另外，如果你的dynamic_cast換成static_cast居然會出錯或者編不過（比方說你居然有地方需要做<code>if(dynamic_cast&lt;_ty*&gt;(a) != nullptr)</code>），那基本上我想你有95%機會結構上有非常值得非議的地方。正常的code其實不太應該需要dynamic_cast這關鍵字的，後面會詳述為什麼有些人會覺得dynamic_cast非用不可。</p>
<p>其他的比方說<code>int*</code>轉<code>char*</code>這種雖然大家都司空見慣(在C真的是見怪不怪的)的轉型，這個是會被打回票的。但是！下面這段code居然是可以過的!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>* a;</div><div class="line"><span class="keyword">char</span>* b;</div><div class="line"> <span class="comment">//當然下面兩段code都過不了compiler</span></div><div class="line"> <span class="comment">//a = static_cast&lt;int*&gt;(b);</span></div><div class="line"> <span class="comment">//b = static_cast&lt;char*&gt;(a);</span></div><div class="line"> </div><div class="line"> <span class="comment">//可是這段是可以過的，WTF</span></div><div class="line">b = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(a));</div></pre></td></tr></table></figure>
<p>如果有人用static_cast寫出這種轉型法，請不要客氣，對這個人飽以老拳，直到他知道再也不該寫出這種code為止。</p>
<p>##dynamic_cast<br>正常來講，這種cast在絕大多數的情況下，會被視為一種設計錯誤，少數幾種情況下則是由於要達成exception neutral所作出的妥協，我們在這裡先忽略掉後面這種情況，來談談為什麼這多半會被視為設計錯誤。</p>
<p>這種用法以粗劣的型別檢查，不該做的向下轉型占了絕大部分。粗劣的型別檢查大概會看起來像是下面這種code</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">A* a = <span class="literal">nullptr</span>;</div><div class="line">a = <span class="keyword">dynamic_cast</span>&lt;A*&gt;(input);</div><div class="line"><span class="keyword">if</span>(a != <span class="literal">nullptr</span>) <span class="comment">//轉型成功了!</span></div><div class="line">&#123;</div><div class="line">	a-&gt;doSomethingOnlyInA();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> </div><div class="line">&#123;</div><div class="line">	<span class="comment">//傳進來的東西居然不是A* 那我們應該怎樣怎樣</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>這種寫法其實就是完全照抄java的關鍵字<code>instanceof</code>的用法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A a = null;</div><div class="line"><span class="keyword">if</span>(input instanceof A) &#123;</div><div class="line">	.....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>這種基本上我想毫無疑問是一種設計錯誤。一個良好的module不應該倚賴RTTI才能正常運作 – 尤其你要知道，RTTI是可以在編譯flag裡面基於各種理由關閉的(以gcc來講，<code>-fno-rtti</code>)。我們應該要倚賴於正確的函數簽名來讓compiler幫我們檢查進來的型別正確性，以及利用各種pattern避免掉「父類別需要去invoke特定某種子類別才有的class function」。上轉下其實很類似這個例子，所以就不贅述了，而且更明顯 – 你需要上轉下，那很明顯你一定哪裡寫錯啦!</p>
<p>##const_cast<br>這東西主要是為了相容性而產生的東西，如果跟相容性無關的話，那我相信也是95%機率以上用錯了。相容性來說，這主要是為了相容3rd party，下面舉個例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//我們有個3rd party長這樣</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> type)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//而我們有一個自己的函數長這樣</span></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//所以編譯這樣會炸掉</span></div><div class="line"><span class="comment">//int succeed = process(getPort(), type);</span></div><div class="line"><span class="comment">//必須要改成這樣才能過</span></div><div class="line"><span class="keyword">int</span> succeed = process(<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(getPort()), type);</div></pre></td></tr></table></figure>
<p>會有人好奇地問，如果我們移除掉const-ness然後去對她做寫入的動作的話會怎樣呢？答案是：很難講，端看這個const是放在哪裡。可能會因為寫入read-only區塊(也就是ELF的.data)炸飛，也有可能在某些compiler裡面相安無事，也有可能因為int被最佳化為short(假設這系統short比int小)，而你寫了一個比short大的東西而讓貞子從你螢幕爬出來…總之，就是未定義，最幸運的情況下就是炸掉當機並且明確地跟你說你試圖寫入read-only區塊。</p>
<p>是的，由於3rd party並沒有掛保證他不會去改動port，當然也沒有把保證寫在signature上（所以我們才會需要const_cast）。當然，int你可以借由把它複製到另外一個int在傳進去來避開這問題，那要是3rd party長這樣呢</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">void</span>** memPageStart, <span class="keyword">int</span> type)</span></span>;</div></pre></td></tr></table></figure>
<p>恩….. XD 這種地雷其實不少見，尤其是你再寫C++時卻需要c-style的3rd party更是常見。 這的確是有危險性（因為你實在是沒辦法保證3rd party在裡面會不會偷寫），不過可以算是一種妥協。</p>
<p>const_cast還有另外一個功能就是移除/增加物件的volatile性質。這個….我只能說，你用到這一步大概99.95%是錯的，請儘量避免這種行為。</p>
<p>##reinterpret_cast<br>其實在C裡面的轉型，扣掉void*互轉以外，大概大多數都是套用這種形式存在，包含struct mask這類的東西。struct mask這名詞可能大家有點陌生，舉個比較接近的例子來看看的話大概就是類似這個</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> rc = connect(sd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</div></pre></td></tr></table></figure>
<p>裡面的<code>sockaddr_in*</code>硬轉成<code>sockaddr*</code>就是一種struct mask。這種轉法其實在C++裡面別無他法，就是得用reinterpret_cast去轉，其他的很常見的char<em>轉int</em>等等都是得用這個東西–基本上這算是一帖萬古黴素，沒有其他的方法能用的情況下就是這樣做。</p>
<p>不過這東西其實頗危險，基本上也是為了相容性而存在的。在C裡面並沒有繼承這東西，所以當有數種不同的結構裡面有相同的構造的時候，就得使用這種方法去轉型。以這個例子來說，sockaddr*保留了14個char的空間給他的子類別自由發揮，所以她長得大概像是這樣子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></div><div class="line"><span class="keyword">unsigned</span>  <span class="keyword">short</span>  sa_family;     <span class="comment">/* address family, AF_xxx */</span></div><div class="line"><span class="keyword">char</span>  sa_data[<span class="number">14</span>];                 <span class="comment">/* 14 bytes of protocol address */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>後面這char[14]是什麼意思，是由他的子類別來決定，比方說其中一個子類別是sockaddr_in<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr_in</span> &#123;</span></div><div class="line"><span class="keyword">short</span>  <span class="keyword">int</span>  sin_family;                      <span class="comment">/* Address family */</span></div><div class="line"><span class="keyword">unsigned</span>  <span class="keyword">short</span>  <span class="keyword">int</span>  sin_port;       <span class="comment">/* Port number */</span></div><div class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>              <span class="comment">/* Internet address */</span></div><div class="line"><span class="keyword">unsigned</span>  <span class="keyword">char</span>  sin_zero[<span class="number">8</span>];         <span class="comment">/* Same size as struct sockaddr */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>值得注意的是sockaddr_in也留了8個char的大小來做padding，以對齊sockaddr的大小。由於C沒有繼承，所以只好用這種方法來達成很類似繼承的效果。在C++中這種API別無選擇，就真的只有reinterpret_cast可以用，因為他們在class層級來看是風馬牛不相干的。</p>
<p>reinterpret_cast最常出包的地方在endian不同的系統，也就是說，只要用了這種轉法，通常也代表了不可移植。至於為什麼endian會出包呢？因為reinterpret_cast的做法基本上是隨著編譯器而變，大家可以仔細想想為什麼。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/08/talking-about-the-four-c-style-casting/" data-id="cj3bltonv000as3si93xuzju5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-fibonacci-sequence-of-three-kinds-of-writing-in-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/01/fibonacci-sequence-of-three-kinds-of-writing-in-c/" class="article-date">
  <time datetime="2013-12-31T23:33:00.000Z" itemprop="datePublished">2014-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/01/fibonacci-sequence-of-three-kinds-of-writing-in-c/">Fibonacci數列的三種寫法 in C++</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>剛剛生病閒著，突然想到連續數列通常在C++有三種表達方法，包含template偏特化，遞迴以及傳統迴圈，於是就拿Fibonacci來作範例寫一組來玩玩看。</p>
<p>這組code展示了這三種寫法。人家說遞迴好寫不是沒有理由的，但是能活著撐過高order的只有迴圈 – 其他都會有call depth爆炸的問題 =P 有興趣的可以玩玩看</p>
<p>###Template &amp; Specialization</p>
<ul>
<li>最顯為人知的特點就是他是編譯期計算。然而，這算是優點也算是缺點，因為template的模板參數必須是型別或者const – 這很合理，我們不可能依賴runtime產生的數據去讓這東西編譯期產生object。優點來講，就是幾乎所有計算的功都在編譯期完成，以下面的範例來講，這幾乎等於是 <figure class="highlight plain"><figcaption><span><< 6765 << endl;```。基本上，很適合建表，但是很占記憶體資源也得很小心的把runtime資料切開。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ 另外其實他邏輯跟寫法都跟Recursive差不多，滿容易變換的，老實講扣掉除錯中的錯誤訊息以外，也滿容易理解的。</div><div class="line">+ 所以同樣的會發生一些call depth方面的問題，不過是炸在不夠力的編譯器上而非runtime。</div><div class="line"></div><div class="line">###Functional Recursive</div><div class="line">+ 看下面的例子就知道這超直覺的，基本上遞迴算是很多數列問題最直觀最直覺的解答。</div><div class="line">+ 但是Call Depth是個很大的問題，以VC6來講，這東西沒辦法處理超過8x以上，而G++似乎也差不多是類似的數字就會炸掉。</div><div class="line">+ 效能普遍很拉蒙，簡單的代價啊（遠目）</div><div class="line"></div><div class="line">###Classic Loop</div><div class="line">+ 基本上這恐怕是三者之中最複雜最難寫的一種</div><div class="line">+ 可是卻是唯一可以活過call depth陷阱的一種做法，下面的20改成100，只有Classic Loop可以活下來</div><div class="line"></div><div class="line">-------------------------</div><div class="line">不過，還是先來個動手玩吧...</div></pre></td></tr></table></figure></li>
</ul>
<p>#include <iostream></iostream></p>
<p>template<int order=""><br>long fibonacci() { return fibonacci<order-1>() + fibonacci<order-2>();}</order-2></order-1></int></p>
<p>template&lt;&gt;<br>long fibonacci<0>() { return 0; }</0></p>
<p>template&lt;&gt;<br>long fibonacci<1>() { return 1; }</1></p>
<p>long fibonacci_rec(int order) {<br>    if(order == 0)<br>        return 0;<br>    if(order == 1)<br>        return 1;<br>    return fibonacci_rec(order - 1) + fibonacci_rec(order - 2);<br>}</p>
<p>long fibonacci_classic(int order) {<br>    if(order == 0)<br>        return 0;<br>    if(order == 1)<br>        return 1;</p>
<pre><code>long past2 = 0, past1 = 1, ret = 0;
for(int i = 0; i &lt; order - 1; ++i) {
    ret = past2 + past1;
    past2 = past1;
    past1 = ret;
}
return ret;
</code></pre><p>}</p>
<p>using namespace std;<br>int main(int argc, char *argv[]) {</p>
<pre><code>cout &lt;&lt; fibonacci&lt;20&gt;() &lt;&lt; endl;
cout &lt;&lt; fibonacci_rec(20) &lt;&lt; endl;
cout &lt;&lt; fibonacci_classic(20) &lt;&lt; endl;

return 0;
</code></pre><p>}<br>```</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/01/fibonacci-sequence-of-three-kinds-of-writing-in-c/" data-id="cj3bltonu0009s3sibocqw3vy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-the-path-to-scheduled-process-singleton" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/26/the-path-to-scheduled-process-singleton/" class="article-date">
  <time datetime="2013-12-26T00:56:00.000Z" itemprop="datePublished">2013-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/26/the-path-to-scheduled-process-singleton/">The path to Scheduled Process Singleton</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我們來看看怎麼改造一個Singleton讓它成為thread-safe。</p>
<p>##本來的Singleton<br>我們先複習一下一個基本的Singleton應該是長什麼樣子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Singleton &#123;</div><div class="line">private:</div><div class="line">    static Singleton* s_defInst;</div><div class="line">    Singleton() = delete;</div><div class="line">    Singleton&amp; Singleton(const Singleton&amp;) = delete;</div><div class="line">    Singleton&amp; operator=(const Singleton&amp;) = delete;</div><div class="line">   </div><div class="line">public:</div><div class="line">    //還記得為什麼是Singleton&amp;而不是Singleton*嗎?</div><div class="line">    static Singleton&amp; getInst() &#123;</div><div class="line">        if(s_defInst == nullptr)</div><div class="line">            s_defInst = new Singleton();</div><div class="line">        return *s_defInst;	</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void methodA();</div><div class="line">    RTValue methodB();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>所以，我們使用Singleton的時候看起來會像是這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Singleton::getInst().methodA();</div></pre></td></tr></table></figure></p>
<p>##我們希望這個Singleton能怎樣呢<br>目前來說，所以我們會希望有一個東西可以傳回一個「thread safe」的handle，這東西完全跟拿::getInst()擁有完全相同的界面，唯一的不同就是他會「排程」丟進Singleton讓他去一個個的做，或者讓它可以「僅鎖定共用資料，但是不會lock thread local」的方法來跑。</p>
<p>所以我們現在至少可以看出這東西會幾個Policy : </p>
<pre><code>1. 我們要能選擇multi thread的「策略」，可以讓他queue，也可以讓他選擇regular，甚至可以指定thread pool
2. 我們要能選擇single的生成方法以及原則(其實這不就是Modern C++ Design第一章的例子嗎)
3. 如果可能的話，Singleton自己有一個骨架，而實作跟界面要能當作Policy傳進來。
</code></pre><p>而讓他看起來應該至少要像是這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ISingletonMethods* s = Singleton::getProxy();</div></pre></td></tr></table></figure></p>
<p>或者更進一步，我們應該要有能力選擇要得到一個blocked或者non-blocked的proxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ISingletonMethods* blocked = Singleton::getProxy&lt;blocked&gt;();</div><div class="line">ISingletonMethods* unblocked = Singleton::getProxy&lt;unblocked&gt;();</div><div class="line"></div><div class="line">//blocked就像普通Singleton，會block自己的這個thread在得到結果</div><div class="line">blocked-&gt;methodA();</div><div class="line"></div><div class="line">//unblocked會讓你直接回傳...雖然我們現在還沒想到要怎麼傳比較漂亮</div><div class="line">//但是沒關係，我們後面會想到方法的 XD</div><div class="line">boost::tuple&lt;int, IRetNotifyHandle&gt; ret = unblocked-&gt;methodA();</div></pre></td></tr></table></figure></p>
<p>##「提供功能的界面以及實作」<br>很明顯的，如果要讓getProxy()跟getInst()一樣的功能的話，他們必須要有一個共通的界面才可以。當然，爽的話寫死也不會有什麼問題，但是我想這不是一個好的coder該做的事情 =P</p>
<p>假設，我們現在有兩個method，分別是<code>void methodA();</code>跟<code>RetValue methodB();</code>，那很明顯我們將會需要一個界面來宣告這個，兩個實作這個<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class ISingletonMethod &#123;</div><div class="line">    public:</div><div class="line">    void methodA() = 0;</div><div class="line">    RetValue methodB() = 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class SingletonMethodImpl : public ISingletonMethod &#123;</div><div class="line">    public:</div><div class="line">    void methodA() &#123; printf(&quot;This is methodA Impl!&quot;); &#125;</div><div class="line">    RetValue methodB &#123; return RetValue(); &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class SingletonMethodProxy : public ISingletonMethod &#123;</div><div class="line">    public:</div><div class="line">    void methodA() &#123; /*還沒有能決定這邊要queue呢 還是thread呢*/ &#125;</div><div class="line">    RetValue methodB() &#123; /*這邊更麻煩，我們甚至還不知道該怎麼拿ret value*/ &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>##決定multi thread策略的Proxy<br>現在我們有界面了，我們也定義出來這些東西了，所以我們可以讓Singleton看起來像是這樣 – 目前來講，我們恐怕只能讓<code>getProxy()</code>傳回指標，這有點尷尬呢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyInterface, typename _TyImpl&gt;</div><div class="line">class Singleton : public _TyImpl &#123;</div><div class="line">private:</div><div class="line">    static Singleton* s_defInst;</div><div class="line">    Singleton() = delete;</div><div class="line">    Singleton&amp; Singleton(const Singleton&amp;) = delete;</div><div class="line">    Singleton&amp; operator=(const Singleton&amp;) = delete;</div><div class="line">   </div><div class="line">public:</div><div class="line">    //還記得為什麼是Singleton&amp;而不是Singleton*嗎?</div><div class="line">    static Singleton&amp; getInst() &#123;</div><div class="line">        if(s_defInst == nullptr)</div><div class="line">            s_defInst = new Singleton();</div><div class="line">        return *s_defInst;	</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    static _TyInterface* getProxy() &#123;</div><div class="line">       /*看來我們的主戰場就在這裡了。*/</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //這兩個沒了，改用繼承的方式繼承過來</div><div class="line">    //void methodA();</div><div class="line">    //RTValue methodB();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>這Proxy該怎麼寫呢？目前來看，Proxy至少要能做到轉發給impl，所以這別無選擇，一定不是繼承，而是template。我們先寫一個什麼都不做的Proxy試試看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyInterface, typename _TyImpl&gt;</div><div class="line">class Proxy : public _TyInterface &#123;</div><div class="line">/*糟糕 中間要轉發一狗票_TyInterface的東西該怎麼寫？*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>很明顯，這種寫法會卡在Proxy無法正確的在編譯期產生正確的Proxy實作。我們可能會希望Proxy「經由某個管理步驟」以後完美的轉發給實作，看起來template展開後會很像是這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class SingletonMethodProxy : public ISingleton &#123;</div><div class="line">	SingletonMethodImpl _impl;</div><div class="line">  void methodA() &#123; doSomething(); _impl-&gt;methodA(); &#125;</div><div class="line">  RetValue methodB() &#123;doSomething(); return _impl-&gt;methodB(); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>問題來了，methodA(), methodB()的Proxy實作我們無法順利地在template裡面轉發給_impl，使用者沒辦法如同呼叫Singleton::getInst().methodA()般的對Proxy做一樣的事情。</p>
<p>這個問題其實困擾了我一陣子，不過後來發現這可以經由override <code>operator-&gt;()</code>跟<code>operator.()</code>來解決一部份，這個code看起來會很像下面這樣…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt;</div><div class="line">class Proxy : public _TyImpl &#123;</div><div class="line">private:</div><div class="line">    _TyImpl&amp; _impl;</div><div class="line">    void doSomething();</div><div class="line">public:</div><div class="line">    Proxy(_TyImpl&amp; impl) : _impl(_TyImpl) &#123; &#125;</div><div class="line">    _TyImpl&amp; operator.() &#123; doSomething(); return _impl; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>這看起來很ok 但是有個問題：operator.是不被允許overload的，我們必須要overload operator-&gt;。overload operator-&gt;會產生另外一個很有趣（但是還算可以接受的）問題，我們先看看整個proxy應該要長什麼樣子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt;</div><div class="line">class Proxy &#123;</div><div class="line">	_TyImpl* _impl;</div><div class="line">	void doSomething() &#123; cout &lt;&lt; &quot;DoSomething&quot; &lt;&lt; endl; &#125;</div><div class="line">	public:</div><div class="line">	Proxy(_TyImpl* impl = nullptr) : _impl(impl) &#123;</div><div class="line">		if(_impl == nullptr)</div><div class="line">			_impl = new _TyImpl();</div><div class="line">	&#125;</div><div class="line">	_TyImpl* operator-&gt;() &#123; doSomething(); return _impl; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>這會產生一個問題，就是這做法其實相當不直覺，有點像smart pointer的做法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Proxy&lt;SingletonMethodImpl&gt;* proxy1 = new Proxy&lt;SingletonMethodImpl&gt;;</div><div class="line">proxy1-&gt;methodA(); //compile time error!</div><div class="line">(*proxy1)-&gt;methodA(); //ok, but WTF??</div><div class="line"></div><div class="line">Proxy&lt;SingletonMethodImpl&gt; proxy2;</div><div class="line">proxy2-&gt;methodA(); //ok, pass, 但是真的很不直覺，很像smart pointer的做法。、</div></pre></td></tr></table></figure></p>
<p>暫時解決了轉發的問題以後，現在要開始解決最難纏的排程的問題。這個其實可以借由Lambda相當清楚地解決一部份，不過仍然相當的抽象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt;</div><div class="line">_TyImpl* Proxy&lt;_TyImpl&gt;::operator-&gt;() &#123;</div><div class="line">    /*所以我們這邊要做什麼來排程呢？*/</div><div class="line">    return _impl; //這邊都把處理權交出去了....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，很明顯的我們不可能直接return _impl了，我們必須要回一個proxy(proxy裡面的proxy，有沒有那麼拗口？)，這個proxy的proxy需要能被cast成_TyImpl，所以大概會長這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt; </div><div class="line">class PProxy &#123;</div><div class="line">	operator _TyImpl*();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2013/12/26/the-path-to-scheduled-process-singleton/" data-id="cj3bltonr0008s3siub2fqufk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-explicit-protocols" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/19/explicit-protocols/" class="article-date">
  <time datetime="2013-12-18T19:12:00.000Z" itemprop="datePublished">2013-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/19/explicit-protocols/">Implicit Protocols</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Implicit protocols, which is hint by its own name, is a protocol that “Other would not know”, and it is a bad design in most cases.</p>
<p>Let us start from a simple example :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">IService getService(String serviceName) &#123;</div><div class="line">	String[] args = serviceName.spilt(&apos; &apos;);</div><div class="line">	if(args.length == 1) //without any arguments</div><div class="line">		return targetService;</div><div class="line">    </div><div class="line">	if(args[1].equalsIgnoreCase(&quot;nonshared&quot;)</div><div class="line"> 		return createServiceFromClassName(serviceName);</div><div class="line">  </div><div class="line">  return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This is a very bad design. We can guess the intentation from source code, for example, if the service name is “IOService” : we can get the IOService from <figure class="highlight plain"><figcaption><span>but if we want to have new instance other then the existed one, we should get this service as ```getService("IOService nonshared");```.</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">We **implicitly** uses the service name as a totally non-related usage. Even with documents, we should not do this because it will insanely increase the complexity of maintaining, and how do others know this? by looking into source code coincidentally observed this usage by others? no, it **NOT** makes sense, avoid this.</div><div class="line"></div><div class="line">Some implicit protocol comes with another name : *Convension*</div><div class="line"></div><div class="line">There is a perfect example in Java. We usually use ```~``` as representive of **Home Dictionary**, so it would come like this code :</div></pre></td></tr></table></figure></p>
<p>File file = new File(“~/Desktop/example.txt”);<br>file.mkdirs();<br>```</p>
<p>You would never find your file under the “~/Desktop” where it is expected, instead, you can guess where it goes :).</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2013/12/19/explicit-protocols/" data-id="cj3bltonq0007s3si7yl70thc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-visual-studio-online" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/03/visual-studio-online/" class="article-date">
  <time datetime="2013-12-03T05:23:00.000Z" itemprop="datePublished">2013-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/03/visual-studio-online/">Visual Studio Online</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.windowsazure.com/zh-tw/pricing/details/visual-studio-online/" target="_blank" rel="external">Visual Studio Online</a>我到了剛剛才搞懂那是啥東西 囧</p>
<p>簡單的說，這並不是一個<strong>“基於HTML5，以及網頁技術，可以讓你只要開瀏覽器就能管理編輯專案”</strong>的東西，而是比較類似GitHub(同時他的主要對手也是GitHub, 嗚呼)，而且比GitHub更加深入的整合的一個雲端專案代管系統。他比GitHub高檔的地方在於他同時結合了CI(不過看起來要價不少)以及與Visual Studio無縫的整合(這聽起來好像廢話)，甚至提供了Eclipse Plugin讓你可以不用Visual Studio也能協同開發。這服務是Windows Azure的一部分，所以可以跟現有的Windows Azure Credit Quota共用。</p>
<p>有點我倒是想說，昨天我才註冊了上去，今天就有小姐打電話來問了，這一天是想問出什麼使用感想阿 XD。另外…MSTW用的節費電話(看號碼應該是Skype?)品質實在堪慮，這樣的客服電話讓客人聽一句漏兩句是不行的 囧興</p>
<p>價格可以參考我剛post的pricing，不過我待過的幾家公司似乎只有一家用Visual Studio當solution，以coder的世界來講，除非是.net開發者，不然這東西看起來似乎不是很討好阿(遠目)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2013/12/03/visual-studio-online/" data-id="cj3bltonp0006s3sirrvjfwey" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-this-is-singleton" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/08/07/this-is-singleton/" class="article-date">
  <time datetime="2013-08-06T18:29:00.000Z" itemprop="datePublished">2013-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/07/this-is-singleton/">This is SINGLETON!</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Singleton…</p>
<p>說真的，這可能可以榮登史上最常見被濫用的Pattern，沒有之一。它本身撰寫並不困難，使用直覺（只是使用上實在又臭又長了一點），在C++裡面就更簡單了，隨便一個class套個<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>class Balabala {<br>    public:<br>        void doSomething();<br>};<br>typedef Loki::SingletonHolder<balabala> SingleBala;</balabala></p>
<p>void test() {<br>    SingleBala::instance().doSomething();<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">甚至要撰寫一個最基本的Singleton也是簡單到爆炸</div></pre></td></tr></table></figure></p>
<p>class Balabala {<br>    private:<br>        static Balabala* defInst;<br>    public:<br>        static inline Balabala&amp; instance() {<br>            if(defInst == null)<br>                defInst = new Balabala();</p>
<pre><code>    return *defInst;
}
</code></pre><p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">當然，Loki的SingletonHolder裡面做了很多有趣的事情，有興趣的人請自己參考一下[這裡](http://sourcecodebrowser.com/asc/1.16.3.0/_singleton_8h_source.html)。當然，請先稍微念一下Modern C++ Design，不然可能連第一個開頭宣告的```CreationPolicy```都不知道是幹嘛的。不過，即使是很初步的大略看了一下，都看得出來Andrei Alexandrescu在設計這個東西的時候，考慮了生命週期以及保留了其他new/delete方法選擇上的彈性。</div><div class="line"></div><div class="line">事實上，也由於```Loki::SingletonHolder&lt;T&gt;```的關係，這個東西在許多系統裡面被濫用到一種莫名其妙的地步， ***幾乎所有希望能夠被在全域存取的物件*** 都會有人想把它寫成Singleton。更糟糕的是，如果你試圖阻止他的話，他會用更糟的static或者毫無章法的在precompiled header內extern去做這種行為。</div></pre></td></tr></table></figure></p>
<p>//in Precompile.pch<br>extern SingleFooService FOO;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">![](https://dl.dropboxusercontent.com/u/3992354/double_facepalm.jpg)</div><div class="line"></div><div class="line">所以，當你有足夠的知識去判斷 ***「這個不該用Singleton」*** 的時候，請很明確地順便跟他說這東西 ***「不該被在不受控管的情況下全域存取」*** ，甚至 ***「根本不該做成全域存取，應該以參考的方式傳入」*** 。很多時候，明明只需要一個String，可是因為貪圖方便不去改member function，直接在裡面呼叫衛星砲Singleton把String傳下來，結果就是把相依性搞得亂七八糟。</div><div class="line"></div><div class="line">有個作者(可以google一下WashuHibiki)做了一個一針見血的評論 : *Not really, most of the use cases for singletons revolve around: &quot;I want to access X, but its not &apos;OO&apos; to use a global, so I&apos;ll dress it up in a class and call it &apos;OO&apos;!&quot;.* 「恩..大多數的Singleton的使用情況，都是在於『我要要存取X，但是使用全域實在不是OO的風格，所以我把X給變裝裝在一個class下，這就是OO了!』」</div><div class="line"></div><div class="line">Singleton的優點我想應該不用說太多，每個人用Singleton一定都是因為他有優勢所以才會去用他。可是，Singleton有很多侷限，很多人卻對這些侷限一無所知而照樣用下去。Singleton有幾個比較明顯的缺點</div><div class="line"></div><div class="line">- 它會讓整個相依性爛成一鍋粥。</div><div class="line">- 它由於本身特性使然，使的它一旦被使用下去就很難去擴充。一旦決策錯誤，大多數的Singleton設計上都很難讓人補救。</div><div class="line">- 也是由於它本身特性使然，它對於threading的處理有很多潛在的問題，尤其是當它有context的時候。</div><div class="line">- 它在很多情況下沒辦法掌握先後順序。舉個最簡單的例子，假設它需要init，而你在foo::instance()的當下壓根不知道她有沒有被init過，你得做個旗標去控制它。然而，並不是所有的地方都可以讓Singleton有正確的context做init的。</div><div class="line"></div><div class="line">這些缺點都是在他被 ***正確*** 使用的時候會碰到的問題，更不用講它被 ***不正確*** 使用的時候會有多少問題。```Loki::SingletonHolder&lt;class&gt;```實在是方便到爆炸，以至於大家什麼class都想往裡面包。我來舉幾個我看過的慘劇</div><div class="line"></div><div class="line">- 某人先宣告了一個```typedef Loki::SingletonHolder&lt;FOO&gt; singleFoo;``` 另外一個人在不同的.h裡面宣告了```typedef Loki::SingletonHolder&lt;FOO&gt; fooSingle```，然後某人開始抱怨為什麼singleFoo會自己改東西，明明沒有code呼叫他</div><div class="line">- 某些情況下的```singleFoo::instance().xxx()```會炸掉，問題幾乎無法重現。後來才發現炸掉的沒有```.init()```，而他一點把握都沒有到底在系統的什麼地方對他作```singleFoo::instance().init(context)```才能正確的把singleFoo init起來，因為他根本沒把握哪個地方會是第一次執行singleFoo的地方。</div><div class="line">- 這個比較偏向於笑話，有人把有state的class包成singleton，比方說DX的```beginDraw()```, ```endDraw()```, 你很多操作一定要放在這兩者之間....可以想想有stack一路call下去會怎樣</div><div class="line">- 這也是個笑話，設計不良的singleton跑在multi thread環境下debug一個難以重現的錯誤debug了一個月</div><div class="line"></div><div class="line">其實先撇掉這些令人噴飯的使用例子，其實大多數Singleton都有一些小撇步來避開這些問題。通常來講，我們要有一個認知： ***Singleton就是Global，不要再催眠自己它不是不是Global了!*** Global的缺點Singleton一個都不會少，我們要用Global的方法去思考這些東西的必要性。</div><div class="line"></div><div class="line">首先，我們要盡量降低Singleton的數量。最簡單的方式就是讓系統整個Singleton剩下一個。比方說我們可能有以下的範例</div></pre></td></tr></table></figure></p>
<p>typedef Loki::SingletonHolder<txmanager> SingleTxManager;<br>typedef Loki::SingletonHolder<bandmanager> SingleBandManager;<br>typedef Loki::SingletonHolder<channelmanager> SingleChannelManager;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我們只允許系統存在一個Singleton，稱為SystemManager</div></pre></td></tr></table></figure></channelmanager></bandmanager></txmanager></p>
<p>class SystemManager {<br>private:<br>    TxManager<em> mTxManager;<br>    BandManager</em> mBandManager;<br>    ChannelManager<em> mChannelManager;<br>public:<br>    TxManager</em> getTxManager();<br>    BandManager<em> getBandManager();<br>    ChannelManager</em> getChannelManager();<br>};</p>
<p>typedef Loki::SingletonHolder<systemmanager> SingleSystem;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">這是最簡單的一步，而且優點非常的明顯。其中一個很明顯的地方在於，當系統需要第二組TxManager的時候，第一種做法會讓整個系統毫無辦法的只能整個大改，但是第二種做法卻可以這樣做</div></pre></td></tr></table></figure></systemmanager></p>
<p>enum TxMgrType {<br>    TX_ORIGINAL,<br>    TX_EXTENDED<br>};</p>
<p>TxManager* getTxManager(TxMgrType type = TX_ORIGINAL);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">這樣就可以輕易的轉換過去，沒有參數的getTxManager會拿到原來的，有傳入TX_EXTENDED的則可以拿到新的。當然，這只是個緩衝跟拖時間的方法，趕快把系統過渡到有兩個TxManager的語法吧... 而且，SystemManager基本上需要考慮的threading issue可以降到最低，因為整個System的Context看起來都是init以後就可以frozen，所以整個系統設計起來將會非常簡單。最後，我們可以比較簡單地找到一個地方去把所有的class初始化。</div><div class="line"></div><div class="line">Singleton的Threading issue也是一個常常被討論的話題。因為這東西被存取的地方實在太多，可能性也太過於頻繁，所以我們必須用許許多多的mutex把很多部分給保護住。但是就有如所有的Semaphore-like的保護一樣，這東西會造成相當程度的設計問題以及死結。所以，為了因應這種問題，我們通常來講會在一些已知的高Threading issue Singleton做一些手腳，比方說把所有的context parameter分開等等...</div></pre></td></tr></table></figure></p>
<p>class FooService {<br>private:<br>    typedef void(<em>FOO_CALLBACK)(void</em>);<br>    const int MAX_WORKING_THREAD = 20;<br>    boost::threadpool::pool s_ThreadPool(MAX_WORKING_THREAD);<br>public:<br>    int doSomething(FOO_CALLBACK callback);<br>};</p>
<p>typedef Loki::SingletonHolder<fooservice> SingleFooService;<br>```</fooservice></p>
<p>簡單的說，我們直接把Thread的事情自己收進來管理，再由一個Callback來把結果傳回去。Java在後期引進了一個概念叫做<a href="http://openhome.cc/Gossip/JavaGossip-V2/CallableFuture.htm" target="_blank" rel="external">Future</a>, <a href="http://www.boost.org/doc/libs/1_46_0/boost/thread/future.hpp" target="_blank" rel="external">C++也有</a>，這個對Threading設計算是非常重要的一個概念，可以大幅減化這方面的設計（也就是讓Singleton傳回一個boost::future，你需要的時候再跑起來就好）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2013/08/07/this-is-singleton/" data-id="cj3bltonk0005s3si3pd7usjz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-suddenly-thought-of-that-old-joke" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/07/18/suddenly-thought-of-that-old-joke/" class="article-date">
  <time datetime="2013-07-18T00:13:00.000Z" itemprop="datePublished">2013-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/18/suddenly-thought-of-that-old-joke/">突然想到這個老掉牙的笑話</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>某天差點被自己害死</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sid = setsid();</div><div class="line">printf(&quot;Starting daemon, sid = %d\n&quot;, sid);</div><div class="line"></div><div class="line">printf(&quot;Disabling each standard file pipes... \n&quot;);</div><div class="line">int FilePipe[3] = &#123;STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO&#125;;</div><div class="line">for(int i = 0; i &lt; sizeof(FilePipe)/sizeof(int); ++i)</div><div class="line">	close(FilePipe[i]);</div><div class="line">printf(&quot;Done\n&quot;);</div></pre></td></tr></table></figure>
<p>恩….誰看出問題在哪了？單單從log上看看起來很像是這個for loop永遠跑不完 XD</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2013/07/18/suddenly-thought-of-that-old-joke/" data-id="cj3bltona0002s3si4yomj8d5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">三月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">六月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">四月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">三月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">二月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">一月 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/02/03/most-vexing-parsingc/">Most Vexing Parsing(C++)</a>
          </li>
        
          <li>
            <a href="/2015/08/23/markdown-text-color-support/">Markdown文字色彩支援</a>
          </li>
        
          <li>
            <a href="/2015/06/15/sourceforge-bundled-third-party-software-causes-serious-disputes/">SourceForge綑綁第三方軟體引發嚴重爭議</a>
          </li>
        
          <li>
            <a href="/2015/04/12/oauth-with-android/">舊文回收:OAuth with Android</a>
          </li>
        
          <li>
            <a href="/2015/03/30/redmine-settings/">Redmine設定(Digital Ocean, Docker)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Rayer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>