<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hex Fantastic</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Rayer&apos;s personal code logs">
<meta property="og:type" content="website">
<meta property="og:title" content="Hex Fantastic">
<meta property="og:url" content="https://rayer.github.com/page/3/index.html">
<meta property="og:site_name" content="Hex Fantastic">
<meta property="og:description" content="Rayer&apos;s personal code logs">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hex Fantastic">
<meta name="twitter:description" content="Rayer&apos;s personal code logs">
  
    <link rel="alternate" href="/atom.xml" title="Hex Fantastic" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hex Fantastic</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">這世界有點無聊，找點架吵吧!</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://rayer.github.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-talking-about-the-c-11-lambda-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/20/talking-about-the-c-11-lambda-3/" class="article-date">
  <time datetime="2014-01-20T02:19:00.000Z" itemprop="datePublished">2014-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/20/talking-about-the-c-11-lambda-3/">淺談C++11 Lambda (3)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不過Lambda也是有侷限的。</p>
<p>廢話少說，我們來複習一下世界上最低效最基礎的泡沫排序法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">void sort(std::vector&lt;int&gt;&amp; raw) &#123;</div><div class="line">	int n = raw.size();</div><div class="line">	int temp;</div><div class="line">	for (int i = n - 1; i &gt; 0; i--)</div><div class="line">	&#123;</div><div class="line">		for (int j = 0; j &lt;= i - 1; j++)</div><div class="line">		&#123;</div><div class="line">			if (raw[j] &gt; raw[j + 1])</div><div class="line">			&#123;</div><div class="line">				temp = raw[j];</div><div class="line">				raw[j] = raw[j + 1];</div><div class="line">				raw[j + 1] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">	//requires C++11</div><div class="line">	std::vector&lt;int&gt; array = &#123;15, 22, 11, 13, 72, 19&#125;;</div><div class="line">	sort(array);</div><div class="line">	</div><div class="line">	for(int i : array)</div><div class="line">		std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>這code能吐槽的地方很多，不過我們先不管 XD。這sort我們需要至少兩種加強：</p>
<ol>
<li>他要能接受所有型別</li>
<li>他要能自定比較子(comparer, 決定A B哪個大哪個小的邏輯)</li>
</ol>
<p>我們先假設所有人對於template都很熟了，第一個需求可以很簡單的用template完成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void sort(std::vector&lt;T&gt;&amp; raw) &#123;</div><div class="line">	int n = raw.size();</div><div class="line">	T temp;</div><div class="line">	for (int i = n - 1; i &gt; 0; i--)</div><div class="line">	&#123;</div><div class="line">		for (int j = 0; j &lt;= i - 1; j++)</div><div class="line">		&#123;</div><div class="line">			if (raw[j] &gt; raw[j + 1])</div><div class="line">			&#123;</div><div class="line">				temp = raw[j];</div><div class="line">				raw[j] = raw[j + 1];</div><div class="line">				raw[j + 1] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>這個我想對於任何稍微懂一點點template的人來說，都不困難，而這個使用也不需要額外的引數參考，可以直接套進去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">std::vector&lt;int&gt; array = &#123;15, 22, 11, 13, 72, 19&#125;;</div><div class="line">sort(array); //不用寫成sort&lt;int&gt;(array);</div></pre></td></tr></table></figure>
<p>接下來就是刺激的部分了。我們需要一個Camparer來加入戰場，我們可以很輕易地寫出來他的簽名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">void sort(std::vector&lt;T&gt;&amp; raw, std::function&lt;bool(T&amp;, T&amp;)&gt; comparer);</div></pre></td></tr></table></figure>
<p>這邊乍看之下是沒太大問題，但是當使用的時候問題就來了：我們需要一個default的comparer，這個comparer只需要<code>return A &gt; B;</code>即可。要是A, B所屬的class沒有定義operator&gt;(), 反正錯誤訊息會提示你說他們無從比對。ok, 所以看起來我們只要按照C++11的做法做一個default lambda來當作預設參數…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T&gt;</div><div class="line">auto defComparer = [](T&amp; A, T&amp;B)-&gt;bool&#123; return A &gt; B; &#125;;</div><div class="line"></div><div class="line">/*</div><div class="line">其實他真正的型別應該是長這樣，只是我們通常用C++11 auto呼籠過去省得麻煩而已 : </div><div class="line">template&lt;typename T&gt;</div><div class="line">std::function&lt;bool(T&amp;, T&amp;)&gt; defaultComparer = [](T&amp; a, T&amp; b)-&gt;bool&#123; return a &gt; b; &#125;;</div><div class="line">*/</div><div class="line"></div><div class="line">template&lt;typename T&gt;</div><div class="line">void sort(std::vector&lt;T&gt;&amp; raw, std::function&lt;bool(T&amp;, T&amp;)&gt; comparer = defaultComparer);</div></pre></td></tr></table></figure>
<p>鐺鐺，編譯器發出了警告，把這行code擋了下來：對不起，lambda不能為template，阿哈哈哈你看看你!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sort_example.cpp:6:29: error: variable &apos;defaultComparer&apos; declared as a template</div><div class="line">std::function&lt;bool(T&amp;, T&amp;)&gt; defaultComparer = [](T&amp; a, T&amp; b)-&gt;bool&#123; return a &gt; b; &#125;;</div><div class="line">                            ^</div></pre></td></tr></table></figure></p>
<p>在C++11中，Lambda的實作是無法template化的。也許我們會想到利用<a href="http://blog.monkeypotion.net/gameprog/beginner/exploring-the-field-of-policy-based-class-design" target="_blank" rel="external">Policy</a>來實作這種情況，可是很不幸的是… function就是function你去哪生個繼承出來？</p>
<p>比較普遍的做法是，使用overload來解決這個問題，所以code看起來會像是這樣 : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line"></div><div class="line">template&lt;typename T&gt;</div><div class="line">bool defaultComparer(const T&amp; a, const T&amp; b) &#123;</div><div class="line">	return a &gt; b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;typename T&gt;</div><div class="line">void sort(std::vector&lt;T&gt;&amp; raw) &#123;</div><div class="line">	int n = raw.size();</div><div class="line">	T temp;</div><div class="line">	for (int i = n - 1; i &gt; 0; i--)</div><div class="line">	&#123;</div><div class="line">		for (int j = 0; j &lt;= i - 1; j++)</div><div class="line">		&#123;</div><div class="line">			if (raw[j] &gt; raw[j + 1])</div><div class="line">			&#123;</div><div class="line">				temp = raw[j];</div><div class="line">				raw[j] = raw[j + 1];</div><div class="line">				raw[j + 1] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;typename T&gt;</div><div class="line">void sort(std::vector&lt;T&gt;&amp; raw, std::function&lt;bool(const T&amp;, const T&amp;)&gt; comparer) &#123;</div><div class="line">	int n = raw.size();</div><div class="line">		T temp;</div><div class="line">		for (int i = n - 1; i &gt; 0; i--)</div><div class="line">		&#123;</div><div class="line">			for (int j = 0; j &lt;= i - 1; j++)</div><div class="line">			&#123;</div><div class="line">				if (comparer(raw[j], raw[j + 1]))</div><div class="line">				&#123;</div><div class="line">					temp = raw[j];</div><div class="line">					raw[j] = raw[j + 1];</div><div class="line">					raw[j + 1] = temp;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TestObject &#123;</div><div class="line">	int a;</div><div class="line">	int b;</div><div class="line">	public:</div><div class="line">	TestObject(int a, int b) : a(a), b(b)&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	TestObject() = default;</div><div class="line">	bool operator&gt;(const TestObject&amp; obj) const &#123;</div><div class="line">		return this-&gt;getValue() &gt; obj.getValue();</div><div class="line">	&#125;</div><div class="line">	int getValue() const &#123;</div><div class="line">		return a * b;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">	//requires C++11</div><div class="line">	std::vector&lt;int&gt; array1 = &#123;15, 22, 11, 13, 72, 19&#125;;</div><div class="line">	//吃沒有comparer的sort, 注意這個sort不需要sort&lt;int&gt; 而且int, double float等等都吃</div><div class="line">	//只要系統有定義&gt;的都吃</div><div class="line">	sort(array1);</div><div class="line">	</div><div class="line">	for(int i : array1)</div><div class="line">		std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</div><div class="line">	</div><div class="line">	std::cout &lt;&lt; std::endl;</div><div class="line">	</div><div class="line"></div><div class="line">			</div><div class="line">	std::vector&lt;TestObject&gt; array2 = &#123;TestObject(1, 4), TestObject(2, 3), TestObject(0, 4), TestObject(3, 3), TestObject(9, 1)&#125;;</div><div class="line">	</div><div class="line">	//印出排序前的Array2</div><div class="line">	for(TestObject a : array2) </div><div class="line">		std::cout &lt;&lt; a.getValue() &lt;&lt; &quot; &quot;;</div><div class="line">	std::cout &lt;&lt; std::endl;</div><div class="line">	</div><div class="line">	//使用有comparer的sort，注意這得指定型別，不過可以試試看她吃不吃沒comparer的預設版本 XD</div><div class="line">	sort&lt;TestObject&gt;(array2, [](const TestObject&amp; a, const TestObject&amp; b)-&gt;bool&#123; return a.getValue() &gt; b.getValue();&#125;);</div><div class="line">	//印出排序後的Array2</div><div class="line">	for(TestObject a : array2) </div><div class="line">		std::cout &lt;&lt; a.getValue() &lt;&lt; &quot; &quot;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>這算一種過渡性的做法吧，哎 :3 (本文仍然會繼續修改）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/20/talking-about-the-c-11-lambda-3/" data-id="cj3bh77m8000d2qsi9j82alyr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-let-your-stdvectoror-something-else-compatible-with-stream-operator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/20/let-your-stdvectoror-something-else-compatible-with-stream-operator/" class="article-date">
  <time datetime="2014-01-19T23:55:00.000Z" itemprop="datePublished">2014-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/20/let-your-stdvectoror-something-else-compatible-with-stream-operator/">Let your std::vector(or something else) compatible with stream operator &lt;&lt;</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Not a quite secret, just have some operator overload trick.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; target, <span class="keyword">const</span> <span class="keyword">char</span>* word) &#123;</div><div class="line">	target.insert(target.end(), word, word + <span class="built_in">std</span>::<span class="built_in">strlen</span>(word));</div><div class="line">	<span class="keyword">return</span> target;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; target, <span class="keyword">char</span> word) &#123;</div><div class="line">	target.push_back(word);</div><div class="line">	<span class="keyword">return</span> target;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; target, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; word) &#123;</div><div class="line">	<span class="keyword">return</span> (target &lt;&lt; word.c_str());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This method have several benefit, first, <code>std::vector</code> can be inserted in templated class, to replace any stream : </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ContinerType&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomethingFooFooFoo</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">somethingBalabala</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; source)</span> </span>&#123;</div><div class="line">  	ContainerType container;</div><div class="line">    container &lt;&lt; source;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//it works</span></div><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">aString</span><span class="params">(<span class="string">"I am a string"</span>)</span></span>;</div><div class="line"></div><div class="line">SomethingFooFooFoo&lt;<span class="built_in">std</span>::iostream&gt; something;</div><div class="line">something.somethingBalabala(aString); <span class="comment">//Works</span></div><div class="line"></div><div class="line">SomethingFooFooFoo&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&gt; somethingElse;</div><div class="line">somethingElse.somethingBalabala(aString); <span class="comment">//also works</span></div></pre></td></tr></table></figure>
<p>It can load up data into container, with controlled type. If you wish, you can even load any byte data into it(using first two implementations). Unloading a vector is quite easy, just use </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const signed char* dumpData = (const signed char*)vectorContainer.data();</div></pre></td></tr></table></figure>
<p>It’s easy, but there is 2 important highlight and ignoring these will easily mess up your code:</p>
<ol>
<li>This data have the same life cycle with the vector container, if the vector is destoryed, this data will no longer valid.</li>
<li>This data should use <code>const</code> to get the data! missing <code>const</code> will directly changes data in vector, and cause unexpected side effect, be advised!</li>
</ol>
<p>For sake of safely, you should get this data via memcpy, or you know what you are doing. in general case, put both <code>dumpData</code> and <code>vectorContainer</code> in the same scope is a good idea, and it is common sense that you should not pass dumpData with pointer to outside of the scope.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/20/let-your-stdvectoror-something-else-compatible-with-stream-operator/" data-id="cj3bh77m2000b2qsiok5bw7bm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-talking-about-the-c-11-lambda-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/20/talking-about-the-c-11-lambda-2/" class="article-date">
  <time datetime="2014-01-19T19:20:00.000Z" itemprop="datePublished">2014-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/20/talking-about-the-c-11-lambda-2/">淺談C++11 Lambda (2)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>(這是一個placeholder 主要是講述C++11 lambda的語法)<br>(這篇還沒寫，但是3已經寫好了 所以…..囧)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/20/talking-about-the-c-11-lambda-2/" data-id="cj3bh77m6000c2qsiskwkibxv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-talking-about-the-c-11-lambda" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/17/talking-about-the-c-11-lambda/" class="article-date">
  <time datetime="2014-01-16T22:39:00.000Z" itemprop="datePublished">2014-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/17/talking-about-the-c-11-lambda/">淺談C++11 Lambda (1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#披荊斬棘的史前時代</p>
<p>Lambda在很多語言中有著相當的地位，不過相似的工具一直在C++11以前都付之闋如，而必須用傳入函數指標的方式來達成類似的效果 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//這種寫法我們稱為C-Stype</div><div class="line">typedef int(*compare)(void*, void*);</div><div class="line">void sort(void** sortingObjects, int length, compare comparer);</div></pre></td></tr></table></figure></p>
<p>這種寫法其實剛好踩在清楚不清楚的邊緣，而且說真的這種void*亂轉看起來也不太靠譜，所以後來大家在C++就改成用template來完成類似的東西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//這個其實是編譯不過去的....</div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">int compare(const CmpObj&amp; Obj1, const CmpObj&amp; Obj2);</div><div class="line"></div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">void sort(const CmpObj* objList, int length, compare&lt;CmpObj&gt; comparer);</div></pre></td></tr></table></figure>
<p>但是typedef其實這舊時代產物是不吃template的（這原因頗長，不過可以想想其實typedef原始目的根本不是拿來定義跟簡化函數指標），所以要不就是用C++11的using關鍵字，要不就是用很類似java的workaround</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//C++11 only</div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">using compare = int (*) (const CmpObj&amp; obj1, const CmpObj&amp; obj2); </div><div class="line"></div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">void sort(const CmpObj* objList, int length, compare&lt;CmpObj&gt; comparer);</div><div class="line"></div><div class="line">//如果想要長得像Java的話...</div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">struct ComparerStr &#123;</div><div class="line">	//這static很重要 少了它就沒辦法ComparerStr&lt;CmpObj&gt;::compare了</div><div class="line">  //當然你要new一個我也不反對，只是這種東西多半是static，不管是new一個還是丟實體進去意義都差不多</div><div class="line">  //new的話還額外多了一個delete的成本跟風險。</div><div class="line">	static int compare(const CmpObj&amp; obj1, const CmpObj&amp; obj2);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//裡面就可以直接取cmp::compare,我就不多寫實做怎麼做了</div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">void sort(const CmpObj* objList, int length, ComparerStr&lt;CmpObj&gt; cmp);</div></pre></td></tr></table></figure>
<p>在還沒有C++11 using的年頭，很顯然的要不就是學這種類java的做法丟class進去，要不就是用很恐怖的函數指標方式來處理這種問題。除了C Programmer以外，我想應該不會有太多正常人喜歡用函數指標，於是大家就開始使用boost::function以及旗下一大套東西來「表達」一個function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">boost::function&lt;int(void*, void*)&gt; comparer;</div></pre></td></tr></table></figure>
<p>但是很不幸的是，雖然C++提供template的技術，卻沒辦法讓你產生一個「template化的template」，所以事實上boost的做法並沒有辦法讓你提供comparer用的型別。</p>
<p>上面的做法其實都有兩個很類似的問題，其中後者是相依于前者的，也就是：</p>
<ul>
<li>我必須把一個僅僅使用一次的comparer額外定義在一個很遙遠的地方，然後才能引用他，而非「他被用到的地方」</li>
<li>要是這個comparer還需要根據一個外部變數來工作，那就死了</li>
</ul>
<p>#後來參戰的Obj-C<br>然後Obj-C開始有類似的技術 叫做Block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//由於id可以吃任何東西，以及由於obj-c語言特性，這個其實連template都用不上</div><div class="line">typedef int* (^comparer_block)(id, id);</div><div class="line">-(void) sort:(NSArray*) objects andComparer:(comparer_block) comparer;</div></pre></td></tr></table></figure></p>
<p>這個我們就不深究了，畢竟這邊以C++ lambda為主。不過請記住， <strong>其實Obj-C的block就是Lambda</strong> </p>
<p>#C++11終於出現的Lambda</p>
<p>我們先拿一個簡單的東西作例子，就拿Bjarne Stroustrup自家的C++11 FAQ舉的例子吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//預設的sort法</div><div class="line">std::sort(v.begin(), v.end());</div><div class="line">//用我們自己決定的comparer來sort</div><div class="line">std::sort(v.begin(), v.end(), [](int a, int b) &#123; return abs(a)&lt;abs(b); &#125;);</div></pre></td></tr></table></figure>
<p>這邊定義了一個新的sort方法，用新的Comparer來定義Sort的順序，從以default改為絕對值。在我們搞清楚怎麼把lambda寫入函式簽名以前，我們先看看這語法上代表的什麼意義</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//-&gt;bool是可以省略的，這個相當於指定回傳型別</div><div class="line">[](int a, int b)-&gt;bool &#123; return abs(a) &lt; abs(b);&#125;</div></pre></td></tr></table></figure>
<p>這邊一共分三個部分，[]等等會提到是什麼意思，而且在這例子裡面其實並沒有用到。中間則是很明顯的他需要兩個參數，都是int，而且是pass by value，最後則是隱式的傳回bool，沒有在裡面宣告。</p>
<p>接下來的問題就是，如果我們要求一個特定簽名的lambda，那這個要怎麼寫？以前的函數指標可能可以寫成這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef int(*CMP)(void*, void*);</div><div class="line">//然後我們可以要求下面兩種之一的寫法</div><div class="line">void sort(void* itemArray, int length, int(*CMP)(void*, void*));</div><div class="line">void sort(void* itemArray, int length, CMP cmp);</div></pre></td></tr></table></figure></p>
<p>在C++11要使用Lambda的場合則是用C++11新的std::function來當作參數來傳遞。另外，雖然上面提到的code很多明明有用到C++11卻可以再沒有–std=c++11的flag下編譯過關， <strong><em>可是下面這組code沒–std=c++11會死，請把它加入g++的參數裡面</em></strong> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//這也沒有真正的sort 說說而已 XD</div><div class="line">template&lt;typename CmpObj&gt;</div><div class="line">void sort(std::vector&lt;CmpObj&gt; objList, std::function&lt;int(CmpObj&amp;, CmpObj&amp;)&gt; func) &#123;</div><div class="line">	CmpObj a, b;</div><div class="line">	a = objList[0];</div><div class="line">	b = objList[1];</div><div class="line">	printf(&quot;return : %d&quot;, func(a, b));</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[]) &#123;</div><div class="line">	int a = 1;</div><div class="line">	int b = 2;</div><div class="line">	std::vector&lt;int&gt; list;</div><div class="line">	list.push_back(a);</div><div class="line">	list.push_back(b);</div><div class="line">  //這個&lt;int&gt;恐怕免不了，g++似乎無法正確推導lambda裡面的template parameter</div><div class="line">	sort&lt;int&gt;(list, [](int x, int y)&#123; printf(&quot;%d, %d\n&quot;, x, y); return 1;&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，這邊先淺嚐即止，剩下的我們留到下一篇討論。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/17/talking-about-the-c-11-lambda/" data-id="cj3bh77ly000a2qsib6yh1boo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-no-modern-design-modern-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/15/no-modern-design-modern-c/" class="article-date">
  <time datetime="2014-01-14T23:42:00.000Z" itemprop="datePublished">2014-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/15/no-modern-design-modern-c/">不再Modern的Modern C++ Design... :)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>寫在前面，我沒有任何貶低這本書的意思。這本書畢竟已經十幾年了，但是仍然是在C++技術領域中的經典之作。不過，在C++11出現的現在，這本在一些地方顯然是有點過時，所以每當我發現裡面有一些目前C++11已經可以cover掉的tech，我會在這裡做些補充。</p>
<p>##STATIC_CHECK (replaced by C++11 static_assert() )<br>會發現這個其實是有點意外，因為這東西其實不太容易發現。我們先看看Loki版本的STATIC_CHECK長什麼樣子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_CHECK(expr) &#123; char unnamed[(expr) ? 1 : 0]; &#125;</span></div></pre></td></tr></table></figure></p>
<p>這個容許你能夠在編譯期檢查一些東西。這東西建立在一個前提下：char[1]是可以合法編譯過關，而char[0]則會造成編譯錯誤，所以他有能力在compile time檢查硬生生的把compiling過程擋下來。以Modern C++ Design自己舉的例子來講<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TO, <span class="keyword">typename</span> FROM&gt;</div><div class="line"><span class="function">TO <span class="title">safe_reinterpret_cast</span><span class="params">(FROM from)</span> </span>&#123;</div><div class="line">        STATIC_CHECK(<span class="keyword">sizeof</span>(TO) &gt;= <span class="keyword">sizeof</span>(FROM));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;TO&gt;(from);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>這個template其實極其簡單，就是如果你試圖把FROM轉成TO，他會先檢查TO是否是個足夠大，至少要足以容納FROM的大小，簡單的說，假設你的TO是char，FROM是double，他就會invoke出STATIC_CHECK，讓STATIC_CHECK編譯錯誤，因為試圖做一個char array大小為0。</p>
<p>不過這段Code因為規格變更，有 <strong>很多</strong> 地方不再正確，我們一個個的看一下。</p>
<p>首先，你會發現char[0]其實已經在C99合法化了，至於[0]的用途請參照<a href="http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html" target="_blank" rel="external">這裡</a>，所以char[0]不再會造成編譯錯誤。另外，reinterpret_cast在C++11下已經會做出大小的檢查，已經不再允許把大的資料結構硬轉成小的資料結構了。</p>
<p>最後一點，也是最重要的是，C++11引入了<code>static_assert(bool willAssert, const char* assertMessage)</code>，使得這種做法不再必要。不過，我們有很多舊有的code，該怎麼辦呢？</p>
<p>在不支援C++11(但是因為C99所以可以合法宣告0長度array的場合)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//既然0不會報錯，-1總會死了吧？</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_CHECK(expr) &#123; char unnamed[(expr) ? 1 : -1]; &#125;</span></div></pre></td></tr></table></figure></p>
<p>支援C++11的場合<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STATIC_CHECK(expr) &#123; static_assert(expr, <span class="meta-string">"Static Assert is invoked!"</span>); &#125;</span></div></pre></td></tr></table></figure></p>
<p>當然，新的code請都用static_assert來取代STATIC_CHECK</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/15/no-modern-design-modern-c/" data-id="cj3bh77lu00082qsi0ba2ydgq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-talk-about-why-mac-gradually-eating-away-at-pc-market" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/15/talk-about-why-mac-gradually-eating-away-at-pc-market/" class="article-date">
  <time datetime="2014-01-14T20:52:00.000Z" itemprop="datePublished">2014-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/15/talk-about-why-mac-gradually-eating-away-at-pc-market/">聊聊Mac為什麼逐漸蠶食PC市場</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前幾天看到一篇文章，北美市場Mac增長25%+，同時間PC市場卻大幅萎縮。Mac跟PC的大戰也打了二十年了，PC始終無法徹底消滅掉Mac，當然Mac有相當多優越的地方，讓我們看看這次此消彼長的轉捩點。</p>
<ul>
<li>大約是在4-5年前，MBP有一波相當大的降價，大約台灣售價從九萬多變成七萬多(17”)，從此MBP不再是超高價的選擇，價格開始跟高階筆電差不多。</li>
<li>第二代MBA的推出以及價格，這個我想是最大的轉捩點。第一代的MBA根本是個問題產品，直到第二代推出以後，價格跟當時超薄的厚度重量以及不錯的手工藝外觀，使得MBA開始為消費市場大量接受(即使當年推出的連core i都還不是，僅僅只是C2D)。說到MAC佔有率的上昇，第二世代的MBA真的功不可沒，也強迫PC陣營弄出個叫做Ultrabook的商業名詞，這波PC陣營在netbook領先的部分，幾乎是被瞬間追平。</li>
<li>Magic Trackpad的推出，把MacBook的體驗完全徹底複製到了iMac上。</li>
<li>平板的興起間接造成OpenGL的興盛以及DX的衰退。</li>
</ul>
<p>雖然我也不知道這是不是Apple的策略，不過顯然從MBA開始的MacBook產線，算是相當程度地打開了OSX的市場，而也一定程度的讓更多人願意使用看看iMac – 而有一個小產品也一定程度的幫助了iMac的銷售，就是Magic Trackpad。雖然這場大戰看起來Mac算是在順風側，不過，誰知道呢 =P 也許哪天PC也會來個驚人的發想，也說不一定，畢竟現在整體仍然是站在PC這端的。</p>
<p>還有一件小事情對PC也是挺不利的 – 就是DirectX開發的沒落。目前來講，許多的遊戲成像引擎仍然支援OpenGL跟DX，但是相當多的遊戲開發商已經傾向于使用Wrapper – 比方說Unity – 而不是直接使用DX或者僅限於DX的引擎。當然目前來講，高端成像引擎如Crysis, GameByro仍然主流支援DX，但是在移植到平板簡單的誘因下，我想採用Wrapper甚至直接用OpenGL開發會越來越多，而這正是PC的痛處 – 支援DX可是別無分號，只有Windows可以做的到。DX跟OpenGL的戰爭也打了10年了，DX曾經贏到幾乎把OpenGL打到一無是處(感謝Khronos努力地守住最後一塊陣地，終於在平板成為主流以後努力開花結果)，而這幾年看來DX卻停滯在11，而且沒辦法在大多數平板上跑。採用OpenGL的意思就是，我們可以很合理的期待mac也能玩(撒花)，這也是許多人的軟肋 – 因為很多遊戲只能在Windows上跑。</p>
<p>這場大戰，Mac慢慢地占了上風，只是離扳平還有很長的一段路要走啊，而且價格也是一個很難彌補的gap。這場大戰，讓我們繼續看下去…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/15/talk-about-why-mac-gradually-eating-away-at-pc-market/" data-id="cj3bh77lw00092qsii305udho" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-talking-about-the-four-c-style-casting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/08/talking-about-the-four-c-style-casting/" class="article-date">
  <time datetime="2014-01-07T23:53:00.000Z" itemprop="datePublished">2014-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/08/talking-about-the-four-c-style-casting/">淺談C++ Style的四種casting</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>這四個的名稱應該大家都很熟了，包含了static_cast, dynamic_cast, const_cast跟reinterpret_cast。不過，這些cast其實或多或少都有一些隱藏的灰色地帶，在這篇文章，我們試圖來看看這四種cast分別有什麼不容易被普通PG看到的地方。</p>
<p>附錄：還有一個駭人聽聞的規格外的東西叫做boost::lexical_cast, 這東西我們晚點聊一下。</p>
<p>##static_cast<br><code>static_cast&lt;Ty&gt;</code>是一個最常見的轉型法，這個轉型其實代表的背後意義是「編譯器被允許做的隱式轉型，void<em>間的互轉，以及non-runetime下安全的子轉父」，任何超出這個範疇的都會直接被編譯器擋下來，包含`int</em><code>轉</code>char<em>`這種行為，都會被擋下。編譯器會自動幫你做的隱式轉換包含了像是int幫你轉成double等等(也就是當你用explicit關鍵字的時候想要編譯器避免的行為)，void</em>互轉是特例，任何東西都能轉成void<em>而void</em>也能轉成任何東西(我一直認為這條規則是為了相容性而存在的)，以及比如<code>class B : public A</code>下允許<code>A* a = static_cast&lt;A*&gt;(new B());</code>這種轉法(但是並不允許相反的<code>B* b = static_cast&lt;B*&gt;(new A());</code>)。</p>
<p>如果你很有把握你沒搞出太大致命的錯誤的話，由於少了很耗資源的RTTI檢查，理論上這種轉法會比dynamic_cast快上非常多。另外，如果你的dynamic_cast換成static_cast居然會出錯或者編不過（比方說你居然有地方需要做<code>if(dynamic_cast&lt;_ty*&gt;(a) != nullptr)</code>），那基本上我想你有95%機會結構上有非常值得非議的地方。正常的code其實不太應該需要dynamic_cast這關鍵字的，後面會詳述為什麼有些人會覺得dynamic_cast非用不可。</p>
<p>其他的比方說<code>int*</code>轉<code>char*</code>這種雖然大家都司空見慣(在C真的是見怪不怪的)的轉型，這個是會被打回票的。但是！下面這段code居然是可以過的!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>* a;</div><div class="line"><span class="keyword">char</span>* b;</div><div class="line"> <span class="comment">//當然下面兩段code都過不了compiler</span></div><div class="line"> <span class="comment">//a = static_cast&lt;int*&gt;(b);</span></div><div class="line"> <span class="comment">//b = static_cast&lt;char*&gt;(a);</span></div><div class="line"> </div><div class="line"> <span class="comment">//可是這段是可以過的，WTF</span></div><div class="line">b = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(a));</div></pre></td></tr></table></figure>
<p>如果有人用static_cast寫出這種轉型法，請不要客氣，對這個人飽以老拳，直到他知道再也不該寫出這種code為止。</p>
<p>##dynamic_cast<br>正常來講，這種cast在絕大多數的情況下，會被視為一種設計錯誤，少數幾種情況下則是由於要達成exception neutral所作出的妥協，我們在這裡先忽略掉後面這種情況，來談談為什麼這多半會被視為設計錯誤。</p>
<p>這種用法以粗劣的型別檢查，不該做的向下轉型占了絕大部分。粗劣的型別檢查大概會看起來像是下面這種code</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">A* a = <span class="literal">nullptr</span>;</div><div class="line">a = <span class="keyword">dynamic_cast</span>&lt;A*&gt;(input);</div><div class="line"><span class="keyword">if</span>(a != <span class="literal">nullptr</span>) <span class="comment">//轉型成功了!</span></div><div class="line">&#123;</div><div class="line">	a-&gt;doSomethingOnlyInA();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> </div><div class="line">&#123;</div><div class="line">	<span class="comment">//傳進來的東西居然不是A* 那我們應該怎樣怎樣</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>這種寫法其實就是完全照抄java的關鍵字<code>instanceof</code>的用法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A a = null;</div><div class="line"><span class="keyword">if</span>(input instanceof A) &#123;</div><div class="line">	.....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>這種基本上我想毫無疑問是一種設計錯誤。一個良好的module不應該倚賴RTTI才能正常運作 – 尤其你要知道，RTTI是可以在編譯flag裡面基於各種理由關閉的(以gcc來講，<code>-fno-rtti</code>)。我們應該要倚賴於正確的函數簽名來讓compiler幫我們檢查進來的型別正確性，以及利用各種pattern避免掉「父類別需要去invoke特定某種子類別才有的class function」。上轉下其實很類似這個例子，所以就不贅述了，而且更明顯 – 你需要上轉下，那很明顯你一定哪裡寫錯啦!</p>
<p>##const_cast<br>這東西主要是為了相容性而產生的東西，如果跟相容性無關的話，那我相信也是95%機率以上用錯了。相容性來說，這主要是為了相容3rd party，下面舉個例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//我們有個3rd party長這樣</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> type)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//而我們有一個自己的函數長這樣</span></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//所以編譯這樣會炸掉</span></div><div class="line"><span class="comment">//int succeed = process(getPort(), type);</span></div><div class="line"><span class="comment">//必須要改成這樣才能過</span></div><div class="line"><span class="keyword">int</span> succeed = process(<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(getPort()), type);</div></pre></td></tr></table></figure>
<p>會有人好奇地問，如果我們移除掉const-ness然後去對她做寫入的動作的話會怎樣呢？答案是：很難講，端看這個const是放在哪裡。可能會因為寫入read-only區塊(也就是ELF的.data)炸飛，也有可能在某些compiler裡面相安無事，也有可能因為int被最佳化為short(假設這系統short比int小)，而你寫了一個比short大的東西而讓貞子從你螢幕爬出來…總之，就是未定義，最幸運的情況下就是炸掉當機並且明確地跟你說你試圖寫入read-only區塊。</p>
<p>是的，由於3rd party並沒有掛保證他不會去改動port，當然也沒有把保證寫在signature上（所以我們才會需要const_cast）。當然，int你可以借由把它複製到另外一個int在傳進去來避開這問題，那要是3rd party長這樣呢</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">void</span>** memPageStart, <span class="keyword">int</span> type)</span></span>;</div></pre></td></tr></table></figure>
<p>恩….. XD 這種地雷其實不少見，尤其是你再寫C++時卻需要c-style的3rd party更是常見。 這的確是有危險性（因為你實在是沒辦法保證3rd party在裡面會不會偷寫），不過可以算是一種妥協。</p>
<p>const_cast還有另外一個功能就是移除/增加物件的volatile性質。這個….我只能說，你用到這一步大概99.95%是錯的，請儘量避免這種行為。</p>
<p>##reinterpret_cast<br>其實在C裡面的轉型，扣掉void*互轉以外，大概大多數都是套用這種形式存在，包含struct mask這類的東西。struct mask這名詞可能大家有點陌生，舉個比較接近的例子來看看的話大概就是類似這個</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> rc = connect(sd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</div></pre></td></tr></table></figure>
<p>裡面的<code>sockaddr_in*</code>硬轉成<code>sockaddr*</code>就是一種struct mask。這種轉法其實在C++裡面別無他法，就是得用reinterpret_cast去轉，其他的很常見的char<em>轉int</em>等等都是得用這個東西–基本上這算是一帖萬古黴素，沒有其他的方法能用的情況下就是這樣做。</p>
<p>不過這東西其實頗危險，基本上也是為了相容性而存在的。在C裡面並沒有繼承這東西，所以當有數種不同的結構裡面有相同的構造的時候，就得使用這種方法去轉型。以這個例子來說，sockaddr*保留了14個char的空間給他的子類別自由發揮，所以她長得大概像是這樣子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></div><div class="line"><span class="keyword">unsigned</span>  <span class="keyword">short</span>  sa_family;     <span class="comment">/* address family, AF_xxx */</span></div><div class="line"><span class="keyword">char</span>  sa_data[<span class="number">14</span>];                 <span class="comment">/* 14 bytes of protocol address */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>後面這char[14]是什麼意思，是由他的子類別來決定，比方說其中一個子類別是sockaddr_in<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr_in</span> &#123;</span></div><div class="line"><span class="keyword">short</span>  <span class="keyword">int</span>  sin_family;                      <span class="comment">/* Address family */</span></div><div class="line"><span class="keyword">unsigned</span>  <span class="keyword">short</span>  <span class="keyword">int</span>  sin_port;       <span class="comment">/* Port number */</span></div><div class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>              <span class="comment">/* Internet address */</span></div><div class="line"><span class="keyword">unsigned</span>  <span class="keyword">char</span>  sin_zero[<span class="number">8</span>];         <span class="comment">/* Same size as struct sockaddr */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>值得注意的是sockaddr_in也留了8個char的大小來做padding，以對齊sockaddr的大小。由於C沒有繼承，所以只好用這種方法來達成很類似繼承的效果。在C++中這種API別無選擇，就真的只有reinterpret_cast可以用，因為他們在class層級來看是風馬牛不相干的。</p>
<p>reinterpret_cast最常出包的地方在endian不同的系統，也就是說，只要用了這種轉法，通常也代表了不可移植。至於為什麼endian會出包呢？因為reinterpret_cast的做法基本上是隨著編譯器而變，大家可以仔細想想為什麼。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/08/talking-about-the-four-c-style-casting/" data-id="cj3bh77lo00072qsi00e2tjrr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-fibonacci-sequence-of-three-kinds-of-writing-in-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/01/fibonacci-sequence-of-three-kinds-of-writing-in-c/" class="article-date">
  <time datetime="2013-12-31T23:33:00.000Z" itemprop="datePublished">2014-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/01/fibonacci-sequence-of-three-kinds-of-writing-in-c/">Fibonacci數列的三種寫法 in C++</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>剛剛生病閒著，突然想到連續數列通常在C++有三種表達方法，包含template偏特化，遞迴以及傳統迴圈，於是就拿Fibonacci來作範例寫一組來玩玩看。</p>
<p>這組code展示了這三種寫法。人家說遞迴好寫不是沒有理由的，但是能活著撐過高order的只有迴圈 – 其他都會有call depth爆炸的問題 =P 有興趣的可以玩玩看</p>
<p>###Template &amp; Specialization</p>
<ul>
<li>最顯為人知的特點就是他是編譯期計算。然而，這算是優點也算是缺點，因為template的模板參數必須是型別或者const – 這很合理，我們不可能依賴runtime產生的數據去讓這東西編譯期產生object。優點來講，就是幾乎所有計算的功都在編譯期完成，以下面的範例來講，這幾乎等於是 <figure class="highlight plain"><figcaption><span><< 6765 << endl;```。基本上，很適合建表，但是很占記憶體資源也得很小心的把runtime資料切開。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ 另外其實他邏輯跟寫法都跟Recursive差不多，滿容易變換的，老實講扣掉除錯中的錯誤訊息以外，也滿容易理解的。</div><div class="line">+ 所以同樣的會發生一些call depth方面的問題，不過是炸在不夠力的編譯器上而非runtime。</div><div class="line"></div><div class="line">###Functional Recursive</div><div class="line">+ 看下面的例子就知道這超直覺的，基本上遞迴算是很多數列問題最直觀最直覺的解答。</div><div class="line">+ 但是Call Depth是個很大的問題，以VC6來講，這東西沒辦法處理超過8x以上，而G++似乎也差不多是類似的數字就會炸掉。</div><div class="line">+ 效能普遍很拉蒙，簡單的代價啊（遠目）</div><div class="line"></div><div class="line">###Classic Loop</div><div class="line">+ 基本上這恐怕是三者之中最複雜最難寫的一種</div><div class="line">+ 可是卻是唯一可以活過call depth陷阱的一種做法，下面的20改成100，只有Classic Loop可以活下來</div><div class="line"></div><div class="line">-------------------------</div><div class="line">不過，還是先來個動手玩吧...</div></pre></td></tr></table></figure></li>
</ul>
<p>#include <iostream></iostream></p>
<p>template<int order=""><br>long fibonacci() { return fibonacci<order-1>() + fibonacci<order-2>();}</order-2></order-1></int></p>
<p>template&lt;&gt;<br>long fibonacci<0>() { return 0; }</0></p>
<p>template&lt;&gt;<br>long fibonacci<1>() { return 1; }</1></p>
<p>long fibonacci_rec(int order) {<br>    if(order == 0)<br>        return 0;<br>    if(order == 1)<br>        return 1;<br>    return fibonacci_rec(order - 1) + fibonacci_rec(order - 2);<br>}</p>
<p>long fibonacci_classic(int order) {<br>    if(order == 0)<br>        return 0;<br>    if(order == 1)<br>        return 1;</p>
<pre><code>long past2 = 0, past1 = 1, ret = 0;
for(int i = 0; i &lt; order - 1; ++i) {
    ret = past2 + past1;
    past2 = past1;
    past1 = ret;
}
return ret;
</code></pre><p>}</p>
<p>using namespace std;<br>int main(int argc, char *argv[]) {</p>
<pre><code>cout &lt;&lt; fibonacci&lt;20&gt;() &lt;&lt; endl;
cout &lt;&lt; fibonacci_rec(20) &lt;&lt; endl;
cout &lt;&lt; fibonacci_classic(20) &lt;&lt; endl;

return 0;
</code></pre><p>}<br>```</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2014/01/01/fibonacci-sequence-of-three-kinds-of-writing-in-c/" data-id="cj3bh77ll00062qsihrnfma2t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-the-path-to-scheduled-process-singleton" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/26/the-path-to-scheduled-process-singleton/" class="article-date">
  <time datetime="2013-12-26T00:56:00.000Z" itemprop="datePublished">2013-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/26/the-path-to-scheduled-process-singleton/">The path to Scheduled Process Singleton</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我們來看看怎麼改造一個Singleton讓它成為thread-safe。</p>
<p>##本來的Singleton<br>我們先複習一下一個基本的Singleton應該是長什麼樣子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Singleton &#123;</div><div class="line">private:</div><div class="line">    static Singleton* s_defInst;</div><div class="line">    Singleton() = delete;</div><div class="line">    Singleton&amp; Singleton(const Singleton&amp;) = delete;</div><div class="line">    Singleton&amp; operator=(const Singleton&amp;) = delete;</div><div class="line">   </div><div class="line">public:</div><div class="line">    //還記得為什麼是Singleton&amp;而不是Singleton*嗎?</div><div class="line">    static Singleton&amp; getInst() &#123;</div><div class="line">        if(s_defInst == nullptr)</div><div class="line">            s_defInst = new Singleton();</div><div class="line">        return *s_defInst;	</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void methodA();</div><div class="line">    RTValue methodB();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>所以，我們使用Singleton的時候看起來會像是這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Singleton::getInst().methodA();</div></pre></td></tr></table></figure></p>
<p>##我們希望這個Singleton能怎樣呢<br>目前來說，所以我們會希望有一個東西可以傳回一個「thread safe」的handle，這東西完全跟拿::getInst()擁有完全相同的界面，唯一的不同就是他會「排程」丟進Singleton讓他去一個個的做，或者讓它可以「僅鎖定共用資料，但是不會lock thread local」的方法來跑。</p>
<p>所以我們現在至少可以看出這東西會幾個Policy : </p>
<pre><code>1. 我們要能選擇multi thread的「策略」，可以讓他queue，也可以讓他選擇regular，甚至可以指定thread pool
2. 我們要能選擇single的生成方法以及原則(其實這不就是Modern C++ Design第一章的例子嗎)
3. 如果可能的話，Singleton自己有一個骨架，而實作跟界面要能當作Policy傳進來。
</code></pre><p>而讓他看起來應該至少要像是這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ISingletonMethods* s = Singleton::getProxy();</div></pre></td></tr></table></figure></p>
<p>或者更進一步，我們應該要有能力選擇要得到一個blocked或者non-blocked的proxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ISingletonMethods* blocked = Singleton::getProxy&lt;blocked&gt;();</div><div class="line">ISingletonMethods* unblocked = Singleton::getProxy&lt;unblocked&gt;();</div><div class="line"></div><div class="line">//blocked就像普通Singleton，會block自己的這個thread在得到結果</div><div class="line">blocked-&gt;methodA();</div><div class="line"></div><div class="line">//unblocked會讓你直接回傳...雖然我們現在還沒想到要怎麼傳比較漂亮</div><div class="line">//但是沒關係，我們後面會想到方法的 XD</div><div class="line">boost::tuple&lt;int, IRetNotifyHandle&gt; ret = unblocked-&gt;methodA();</div></pre></td></tr></table></figure></p>
<p>##「提供功能的界面以及實作」<br>很明顯的，如果要讓getProxy()跟getInst()一樣的功能的話，他們必須要有一個共通的界面才可以。當然，爽的話寫死也不會有什麼問題，但是我想這不是一個好的coder該做的事情 =P</p>
<p>假設，我們現在有兩個method，分別是<code>void methodA();</code>跟<code>RetValue methodB();</code>，那很明顯我們將會需要一個界面來宣告這個，兩個實作這個<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class ISingletonMethod &#123;</div><div class="line">    public:</div><div class="line">    void methodA() = 0;</div><div class="line">    RetValue methodB() = 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class SingletonMethodImpl : public ISingletonMethod &#123;</div><div class="line">    public:</div><div class="line">    void methodA() &#123; printf(&quot;This is methodA Impl!&quot;); &#125;</div><div class="line">    RetValue methodB &#123; return RetValue(); &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class SingletonMethodProxy : public ISingletonMethod &#123;</div><div class="line">    public:</div><div class="line">    void methodA() &#123; /*還沒有能決定這邊要queue呢 還是thread呢*/ &#125;</div><div class="line">    RetValue methodB() &#123; /*這邊更麻煩，我們甚至還不知道該怎麼拿ret value*/ &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>##決定multi thread策略的Proxy<br>現在我們有界面了，我們也定義出來這些東西了，所以我們可以讓Singleton看起來像是這樣 – 目前來講，我們恐怕只能讓<code>getProxy()</code>傳回指標，這有點尷尬呢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyInterface, typename _TyImpl&gt;</div><div class="line">class Singleton : public _TyImpl &#123;</div><div class="line">private:</div><div class="line">    static Singleton* s_defInst;</div><div class="line">    Singleton() = delete;</div><div class="line">    Singleton&amp; Singleton(const Singleton&amp;) = delete;</div><div class="line">    Singleton&amp; operator=(const Singleton&amp;) = delete;</div><div class="line">   </div><div class="line">public:</div><div class="line">    //還記得為什麼是Singleton&amp;而不是Singleton*嗎?</div><div class="line">    static Singleton&amp; getInst() &#123;</div><div class="line">        if(s_defInst == nullptr)</div><div class="line">            s_defInst = new Singleton();</div><div class="line">        return *s_defInst;	</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    static _TyInterface* getProxy() &#123;</div><div class="line">       /*看來我們的主戰場就在這裡了。*/</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //這兩個沒了，改用繼承的方式繼承過來</div><div class="line">    //void methodA();</div><div class="line">    //RTValue methodB();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>這Proxy該怎麼寫呢？目前來看，Proxy至少要能做到轉發給impl，所以這別無選擇，一定不是繼承，而是template。我們先寫一個什麼都不做的Proxy試試看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyInterface, typename _TyImpl&gt;</div><div class="line">class Proxy : public _TyInterface &#123;</div><div class="line">/*糟糕 中間要轉發一狗票_TyInterface的東西該怎麼寫？*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>很明顯，這種寫法會卡在Proxy無法正確的在編譯期產生正確的Proxy實作。我們可能會希望Proxy「經由某個管理步驟」以後完美的轉發給實作，看起來template展開後會很像是這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class SingletonMethodProxy : public ISingleton &#123;</div><div class="line">	SingletonMethodImpl _impl;</div><div class="line">  void methodA() &#123; doSomething(); _impl-&gt;methodA(); &#125;</div><div class="line">  RetValue methodB() &#123;doSomething(); return _impl-&gt;methodB(); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>問題來了，methodA(), methodB()的Proxy實作我們無法順利地在template裡面轉發給_impl，使用者沒辦法如同呼叫Singleton::getInst().methodA()般的對Proxy做一樣的事情。</p>
<p>這個問題其實困擾了我一陣子，不過後來發現這可以經由override <code>operator-&gt;()</code>跟<code>operator.()</code>來解決一部份，這個code看起來會很像下面這樣…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt;</div><div class="line">class Proxy : public _TyImpl &#123;</div><div class="line">private:</div><div class="line">    _TyImpl&amp; _impl;</div><div class="line">    void doSomething();</div><div class="line">public:</div><div class="line">    Proxy(_TyImpl&amp; impl) : _impl(_TyImpl) &#123; &#125;</div><div class="line">    _TyImpl&amp; operator.() &#123; doSomething(); return _impl; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>這看起來很ok 但是有個問題：operator.是不被允許overload的，我們必須要overload operator-&gt;。overload operator-&gt;會產生另外一個很有趣（但是還算可以接受的）問題，我們先看看整個proxy應該要長什麼樣子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt;</div><div class="line">class Proxy &#123;</div><div class="line">	_TyImpl* _impl;</div><div class="line">	void doSomething() &#123; cout &lt;&lt; &quot;DoSomething&quot; &lt;&lt; endl; &#125;</div><div class="line">	public:</div><div class="line">	Proxy(_TyImpl* impl = nullptr) : _impl(impl) &#123;</div><div class="line">		if(_impl == nullptr)</div><div class="line">			_impl = new _TyImpl();</div><div class="line">	&#125;</div><div class="line">	_TyImpl* operator-&gt;() &#123; doSomething(); return _impl; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>這會產生一個問題，就是這做法其實相當不直覺，有點像smart pointer的做法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Proxy&lt;SingletonMethodImpl&gt;* proxy1 = new Proxy&lt;SingletonMethodImpl&gt;;</div><div class="line">proxy1-&gt;methodA(); //compile time error!</div><div class="line">(*proxy1)-&gt;methodA(); //ok, but WTF??</div><div class="line"></div><div class="line">Proxy&lt;SingletonMethodImpl&gt; proxy2;</div><div class="line">proxy2-&gt;methodA(); //ok, pass, 但是真的很不直覺，很像smart pointer的做法。、</div></pre></td></tr></table></figure></p>
<p>暫時解決了轉發的問題以後，現在要開始解決最難纏的排程的問題。這個其實可以借由Lambda相當清楚地解決一部份，不過仍然相當的抽象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt;</div><div class="line">_TyImpl* Proxy&lt;_TyImpl&gt;::operator-&gt;() &#123;</div><div class="line">    /*所以我們這邊要做什麼來排程呢？*/</div><div class="line">    return _impl; //這邊都把處理權交出去了....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，很明顯的我們不可能直接return _impl了，我們必須要回一個proxy(proxy裡面的proxy，有沒有那麼拗口？)，這個proxy的proxy需要能被cast成_TyImpl，所以大概會長這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt; </div><div class="line">class PProxy &#123;</div><div class="line">	operator _TyImpl*();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2013/12/26/the-path-to-scheduled-process-singleton/" data-id="cj3bh77lk00052qsii2cfjhtx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-explicit-protocols" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/19/explicit-protocols/" class="article-date">
  <time datetime="2013-12-18T19:12:00.000Z" itemprop="datePublished">2013-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/19/explicit-protocols/">Implicit Protocols</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Implicit protocols, which is hint by its own name, is a protocol that “Other would not know”, and it is a bad design in most cases.</p>
<p>Let us start from a simple example :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">IService getService(String serviceName) &#123;</div><div class="line">	String[] args = serviceName.spilt(&apos; &apos;);</div><div class="line">	if(args.length == 1) //without any arguments</div><div class="line">		return targetService;</div><div class="line">    </div><div class="line">	if(args[1].equalsIgnoreCase(&quot;nonshared&quot;)</div><div class="line"> 		return createServiceFromClassName(serviceName);</div><div class="line">  </div><div class="line">  return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This is a very bad design. We can guess the intentation from source code, for example, if the service name is “IOService” : we can get the IOService from <figure class="highlight plain"><figcaption><span>but if we want to have new instance other then the existed one, we should get this service as ```getService("IOService nonshared");```.</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">We **implicitly** uses the service name as a totally non-related usage. Even with documents, we should not do this because it will insanely increase the complexity of maintaining, and how do others know this? by looking into source code coincidentally observed this usage by others? no, it **NOT** makes sense, avoid this.</div><div class="line"></div><div class="line">Some implicit protocol comes with another name : *Convension*</div><div class="line"></div><div class="line">There is a perfect example in Java. We usually use ```~``` as representive of **Home Dictionary**, so it would come like this code :</div></pre></td></tr></table></figure></p>
<p>File file = new File(“~/Desktop/example.txt”);<br>file.mkdirs();<br>```</p>
<p>You would never find your file under the “~/Desktop” where it is expected, instead, you can guess where it goes :).</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://rayer.github.com/2013/12/19/explicit-protocols/" data-id="cj3bh77lh00042qsiiwdasxon" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/02/03/most-vexing-parsingc/">Most Vexing Parsing(C++)</a>
          </li>
        
          <li>
            <a href="/2015/08/23/markdown-text-color-support/">Markdown文字色彩支援</a>
          </li>
        
          <li>
            <a href="/2015/07/26/create-your-own-pgp-digital-signature/">創造一個自己的PGP電子簽章</a>
          </li>
        
          <li>
            <a href="/2015/06/15/sourceforge-bundled-third-party-software-causes-serious-disputes/">SourceForge綑綁第三方軟體引發嚴重爭議</a>
          </li>
        
          <li>
            <a href="/2015/04/12/oauth-with-android/">舊文回收:OAuth with Android</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Rayer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>