<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-talk-about-why-mac-gradually-eating-away-at-pc-market" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/15/talk-about-why-mac-gradually-eating-away-at-pc-market/" class="article-date">
  <time datetime="2014-01-14T20:52:00.000Z" itemprop="datePublished">2014-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/15/talk-about-why-mac-gradually-eating-away-at-pc-market/">聊聊Mac為什麼逐漸蠶食PC市場</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前幾天看到一篇文章，北美市場Mac增長25%+，同時間PC市場卻大幅萎縮。Mac跟PC的大戰也打了二十年了，PC始終無法徹底消滅掉Mac，當然Mac有相當多優越的地方，讓我們看看這次此消彼長的轉捩點。</p>
<ul>
<li>大約是在4-5年前，MBP有一波相當大的降價，大約台灣售價從九萬多變成七萬多(17”)，從此MBP不再是超高價的選擇，價格開始跟高階筆電差不多。</li>
<li>第二代MBA的推出以及價格，這個我想是最大的轉捩點。第一代的MBA根本是個問題產品，直到第二代推出以後，價格跟當時超薄的厚度重量以及不錯的手工藝外觀，使得MBA開始為消費市場大量接受(即使當年推出的連core i都還不是，僅僅只是C2D)。說到MAC佔有率的上昇，第二世代的MBA真的功不可沒，也強迫PC陣營弄出個叫做Ultrabook的商業名詞，這波PC陣營在netbook領先的部分，幾乎是被瞬間追平。</li>
<li>Magic Trackpad的推出，把MacBook的體驗完全徹底複製到了iMac上。</li>
<li>平板的興起間接造成OpenGL的興盛以及DX的衰退。</li>
</ul>
<p>雖然我也不知道這是不是Apple的策略，不過顯然從MBA開始的MacBook產線，算是相當程度地打開了OSX的市場，而也一定程度的讓更多人願意使用看看iMac – 而有一個小產品也一定程度的幫助了iMac的銷售，就是Magic Trackpad。雖然這場大戰看起來Mac算是在順風側，不過，誰知道呢 =P 也許哪天PC也會來個驚人的發想，也說不一定，畢竟現在整體仍然是站在PC這端的。</p>
<p>還有一件小事情對PC也是挺不利的 – 就是DirectX開發的沒落。目前來講，許多的遊戲成像引擎仍然支援OpenGL跟DX，但是相當多的遊戲開發商已經傾向于使用Wrapper – 比方說Unity – 而不是直接使用DX或者僅限於DX的引擎。當然目前來講，高端成像引擎如Crysis, GameByro仍然主流支援DX，但是在移植到平板簡單的誘因下，我想採用Wrapper甚至直接用OpenGL開發會越來越多，而這正是PC的痛處 – 支援DX可是別無分號，只有Windows可以做的到。DX跟OpenGL的戰爭也打了10年了，DX曾經贏到幾乎把OpenGL打到一無是處(感謝Khronos努力地守住最後一塊陣地，終於在平板成為主流以後努力開花結果)，而這幾年看來DX卻停滯在11，而且沒辦法在大多數平板上跑。採用OpenGL的意思就是，我們可以很合理的期待mac也能玩(撒花)，這也是許多人的軟肋 – 因為很多遊戲只能在Windows上跑。</p>
<p>這場大戰，Mac慢慢地占了上風，只是離扳平還有很長的一段路要走啊，而且價格也是一個很難彌補的gap。這場大戰，讓我們繼續看下去…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/15/talk-about-why-mac-gradually-eating-away-at-pc-market/" data-id="cj3b76vo90009hzsi0dv2i6nc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-talking-about-the-four-c-style-casting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/08/talking-about-the-four-c-style-casting/" class="article-date">
  <time datetime="2014-01-07T23:53:00.000Z" itemprop="datePublished">2014-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/08/talking-about-the-four-c-style-casting/">淺談C++ Style的四種casting</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>這四個的名稱應該大家都很熟了，包含了static_cast, dynamic_cast, const_cast跟reinterpret_cast。不過，這些cast其實或多或少都有一些隱藏的灰色地帶，在這篇文章，我們試圖來看看這四種cast分別有什麼不容易被普通PG看到的地方。</p>
<p>附錄：還有一個駭人聽聞的規格外的東西叫做boost::lexical_cast, 這東西我們晚點聊一下。</p>
<p>##static_cast<br><code>static_cast&lt;Ty&gt;</code>是一個最常見的轉型法，這個轉型其實代表的背後意義是「編譯器被允許做的隱式轉型，void<em>間的互轉，以及non-runetime下安全的子轉父」，任何超出這個範疇的都會直接被編譯器擋下來，包含`int</em><code>轉</code>char<em>`這種行為，都會被擋下。編譯器會自動幫你做的隱式轉換包含了像是int幫你轉成double等等(也就是當你用explicit關鍵字的時候想要編譯器避免的行為)，void</em>互轉是特例，任何東西都能轉成void<em>而void</em>也能轉成任何東西(我一直認為這條規則是為了相容性而存在的)，以及比如<code>class B : public A</code>下允許<code>A* a = static_cast&lt;A*&gt;(new B());</code>這種轉法(但是並不允許相反的<code>B* b = static_cast&lt;B*&gt;(new A());</code>)。</p>
<p>如果你很有把握你沒搞出太大致命的錯誤的話，由於少了很耗資源的RTTI檢查，理論上這種轉法會比dynamic_cast快上非常多。另外，如果你的dynamic_cast換成static_cast居然會出錯或者編不過（比方說你居然有地方需要做<code>if(dynamic_cast&lt;_ty*&gt;(a) != nullptr)</code>），那基本上我想你有95%機會結構上有非常值得非議的地方。正常的code其實不太應該需要dynamic_cast這關鍵字的，後面會詳述為什麼有些人會覺得dynamic_cast非用不可。</p>
<p>其他的比方說<code>int*</code>轉<code>char*</code>這種雖然大家都司空見慣(在C真的是見怪不怪的)的轉型，這個是會被打回票的。但是！下面這段code居然是可以過的!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>* a;</div><div class="line"><span class="keyword">char</span>* b;</div><div class="line"> <span class="comment">//當然下面兩段code都過不了compiler</span></div><div class="line"> <span class="comment">//a = static_cast&lt;int*&gt;(b);</span></div><div class="line"> <span class="comment">//b = static_cast&lt;char*&gt;(a);</span></div><div class="line"> </div><div class="line"> <span class="comment">//可是這段是可以過的，WTF</span></div><div class="line">b = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(a));</div></pre></td></tr></table></figure>
<p>如果有人用static_cast寫出這種轉型法，請不要客氣，對這個人飽以老拳，直到他知道再也不該寫出這種code為止。</p>
<p>##dynamic_cast<br>正常來講，這種cast在絕大多數的情況下，會被視為一種設計錯誤，少數幾種情況下則是由於要達成exception neutral所作出的妥協，我們在這裡先忽略掉後面這種情況，來談談為什麼這多半會被視為設計錯誤。</p>
<p>這種用法以粗劣的型別檢查，不該做的向下轉型占了絕大部分。粗劣的型別檢查大概會看起來像是下面這種code</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">A* a = <span class="literal">nullptr</span>;</div><div class="line">a = <span class="keyword">dynamic_cast</span>&lt;A*&gt;(input);</div><div class="line"><span class="keyword">if</span>(a != <span class="literal">nullptr</span>) <span class="comment">//轉型成功了!</span></div><div class="line">&#123;</div><div class="line">	a-&gt;doSomethingOnlyInA();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> </div><div class="line">&#123;</div><div class="line">	<span class="comment">//傳進來的東西居然不是A* 那我們應該怎樣怎樣</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>這種寫法其實就是完全照抄java的關鍵字<code>instanceof</code>的用法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A a = null;</div><div class="line"><span class="keyword">if</span>(input instanceof A) &#123;</div><div class="line">	.....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>這種基本上我想毫無疑問是一種設計錯誤。一個良好的module不應該倚賴RTTI才能正常運作 – 尤其你要知道，RTTI是可以在編譯flag裡面基於各種理由關閉的(以gcc來講，<code>-fno-rtti</code>)。我們應該要倚賴於正確的函數簽名來讓compiler幫我們檢查進來的型別正確性，以及利用各種pattern避免掉「父類別需要去invoke特定某種子類別才有的class function」。上轉下其實很類似這個例子，所以就不贅述了，而且更明顯 – 你需要上轉下，那很明顯你一定哪裡寫錯啦!</p>
<p>##const_cast<br>這東西主要是為了相容性而產生的東西，如果跟相容性無關的話，那我相信也是95%機率以上用錯了。相容性來說，這主要是為了相容3rd party，下面舉個例子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//我們有個3rd party長這樣</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> type)</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//而我們有一個自己的函數長這樣</span></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//所以編譯這樣會炸掉</span></div><div class="line"><span class="comment">//int succeed = process(getPort(), type);</span></div><div class="line"><span class="comment">//必須要改成這樣才能過</span></div><div class="line"><span class="keyword">int</span> succeed = process(<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&gt;(getPort()), type);</div></pre></td></tr></table></figure>
<p>會有人好奇地問，如果我們移除掉const-ness然後去對她做寫入的動作的話會怎樣呢？答案是：很難講，端看這個const是放在哪裡。可能會因為寫入read-only區塊(也就是ELF的.data)炸飛，也有可能在某些compiler裡面相安無事，也有可能因為int被最佳化為short(假設這系統short比int小)，而你寫了一個比short大的東西而讓貞子從你螢幕爬出來…總之，就是未定義，最幸運的情況下就是炸掉當機並且明確地跟你說你試圖寫入read-only區塊。</p>
<p>是的，由於3rd party並沒有掛保證他不會去改動port，當然也沒有把保證寫在signature上（所以我們才會需要const_cast）。當然，int你可以借由把它複製到另外一個int在傳進去來避開這問題，那要是3rd party長這樣呢</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">void</span>** memPageStart, <span class="keyword">int</span> type)</span></span>;</div></pre></td></tr></table></figure>
<p>恩….. XD 這種地雷其實不少見，尤其是你再寫C++時卻需要c-style的3rd party更是常見。 這的確是有危險性（因為你實在是沒辦法保證3rd party在裡面會不會偷寫），不過可以算是一種妥協。</p>
<p>const_cast還有另外一個功能就是移除/增加物件的volatile性質。這個….我只能說，你用到這一步大概99.95%是錯的，請儘量避免這種行為。</p>
<p>##reinterpret_cast<br>其實在C裡面的轉型，扣掉void*互轉以外，大概大多數都是套用這種形式存在，包含struct mask這類的東西。struct mask這名詞可能大家有點陌生，舉個比較接近的例子來看看的話大概就是類似這個</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> rc = connect(sd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</div></pre></td></tr></table></figure>
<p>裡面的<code>sockaddr_in*</code>硬轉成<code>sockaddr*</code>就是一種struct mask。這種轉法其實在C++裡面別無他法，就是得用reinterpret_cast去轉，其他的很常見的char<em>轉int</em>等等都是得用這個東西–基本上這算是一帖萬古黴素，沒有其他的方法能用的情況下就是這樣做。</p>
<p>不過這東西其實頗危險，基本上也是為了相容性而存在的。在C裡面並沒有繼承這東西，所以當有數種不同的結構裡面有相同的構造的時候，就得使用這種方法去轉型。以這個例子來說，sockaddr*保留了14個char的空間給他的子類別自由發揮，所以她長得大概像是這樣子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></div><div class="line"><span class="keyword">unsigned</span>  <span class="keyword">short</span>  sa_family;     <span class="comment">/* address family, AF_xxx */</span></div><div class="line"><span class="keyword">char</span>  sa_data[<span class="number">14</span>];                 <span class="comment">/* 14 bytes of protocol address */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>後面這char[14]是什麼意思，是由他的子類別來決定，比方說其中一個子類別是sockaddr_in<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr_in</span> &#123;</span></div><div class="line"><span class="keyword">short</span>  <span class="keyword">int</span>  sin_family;                      <span class="comment">/* Address family */</span></div><div class="line"><span class="keyword">unsigned</span>  <span class="keyword">short</span>  <span class="keyword">int</span>  sin_port;       <span class="comment">/* Port number */</span></div><div class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>              <span class="comment">/* Internet address */</span></div><div class="line"><span class="keyword">unsigned</span>  <span class="keyword">char</span>  sin_zero[<span class="number">8</span>];         <span class="comment">/* Same size as struct sockaddr */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>值得注意的是sockaddr_in也留了8個char的大小來做padding，以對齊sockaddr的大小。由於C沒有繼承，所以只好用這種方法來達成很類似繼承的效果。在C++中這種API別無選擇，就真的只有reinterpret_cast可以用，因為他們在class層級來看是風馬牛不相干的。</p>
<p>reinterpret_cast最常出包的地方在endian不同的系統，也就是說，只要用了這種轉法，通常也代表了不可移植。至於為什麼endian會出包呢？因為reinterpret_cast的做法基本上是隨著編譯器而變，大家可以仔細想想為什麼。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/08/talking-about-the-four-c-style-casting/" data-id="cj3b76vo00007hzsi10d023kn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-fibonacci-sequence-of-three-kinds-of-writing-in-c" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/01/fibonacci-sequence-of-three-kinds-of-writing-in-c/" class="article-date">
  <time datetime="2013-12-31T23:33:00.000Z" itemprop="datePublished">2014-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/01/fibonacci-sequence-of-three-kinds-of-writing-in-c/">Fibonacci數列的三種寫法 in C++</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>剛剛生病閒著，突然想到連續數列通常在C++有三種表達方法，包含template偏特化，遞迴以及傳統迴圈，於是就拿Fibonacci來作範例寫一組來玩玩看。</p>
<p>這組code展示了這三種寫法。人家說遞迴好寫不是沒有理由的，但是能活著撐過高order的只有迴圈 – 其他都會有call depth爆炸的問題 =P 有興趣的可以玩玩看</p>
<p>###Template &amp; Specialization</p>
<ul>
<li>最顯為人知的特點就是他是編譯期計算。然而，這算是優點也算是缺點，因為template的模板參數必須是型別或者const – 這很合理，我們不可能依賴runtime產生的數據去讓這東西編譯期產生object。優點來講，就是幾乎所有計算的功都在編譯期完成，以下面的範例來講，這幾乎等於是 <figure class="highlight plain"><figcaption><span><< 6765 << endl;```。基本上，很適合建表，但是很占記憶體資源也得很小心的把runtime資料切開。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ 另外其實他邏輯跟寫法都跟Recursive差不多，滿容易變換的，老實講扣掉除錯中的錯誤訊息以外，也滿容易理解的。</div><div class="line">+ 所以同樣的會發生一些call depth方面的問題，不過是炸在不夠力的編譯器上而非runtime。</div><div class="line"></div><div class="line">###Functional Recursive</div><div class="line">+ 看下面的例子就知道這超直覺的，基本上遞迴算是很多數列問題最直觀最直覺的解答。</div><div class="line">+ 但是Call Depth是個很大的問題，以VC6來講，這東西沒辦法處理超過8x以上，而G++似乎也差不多是類似的數字就會炸掉。</div><div class="line">+ 效能普遍很拉蒙，簡單的代價啊（遠目）</div><div class="line"></div><div class="line">###Classic Loop</div><div class="line">+ 基本上這恐怕是三者之中最複雜最難寫的一種</div><div class="line">+ 可是卻是唯一可以活過call depth陷阱的一種做法，下面的20改成100，只有Classic Loop可以活下來</div><div class="line"></div><div class="line">-------------------------</div><div class="line">不過，還是先來個動手玩吧...</div></pre></td></tr></table></figure></li>
</ul>
<p>#include <iostream></iostream></p>
<p>template<int order=""><br>long fibonacci() { return fibonacci<order-1>() + fibonacci<order-2>();}</order-2></order-1></int></p>
<p>template&lt;&gt;<br>long fibonacci<0>() { return 0; }</0></p>
<p>template&lt;&gt;<br>long fibonacci<1>() { return 1; }</1></p>
<p>long fibonacci_rec(int order) {<br>    if(order == 0)<br>        return 0;<br>    if(order == 1)<br>        return 1;<br>    return fibonacci_rec(order - 1) + fibonacci_rec(order - 2);<br>}</p>
<p>long fibonacci_classic(int order) {<br>    if(order == 0)<br>        return 0;<br>    if(order == 1)<br>        return 1;</p>
<pre><code>long past2 = 0, past1 = 1, ret = 0;
for(int i = 0; i &lt; order - 1; ++i) {
    ret = past2 + past1;
    past2 = past1;
    past1 = ret;
}
return ret;
</code></pre><p>}</p>
<p>using namespace std;<br>int main(int argc, char *argv[]) {</p>
<pre><code>cout &lt;&lt; fibonacci&lt;20&gt;() &lt;&lt; endl;
cout &lt;&lt; fibonacci_rec(20) &lt;&lt; endl;
cout &lt;&lt; fibonacci_classic(20) &lt;&lt; endl;

return 0;
</code></pre><p>}<br>```</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/01/fibonacci-sequence-of-three-kinds-of-writing-in-c/" data-id="cj3b76vny0006hzsicg1cnzho" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-the-path-to-scheduled-process-singleton" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/26/the-path-to-scheduled-process-singleton/" class="article-date">
  <time datetime="2013-12-26T00:56:00.000Z" itemprop="datePublished">2013-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/26/the-path-to-scheduled-process-singleton/">The path to Scheduled Process Singleton</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我們來看看怎麼改造一個Singleton讓它成為thread-safe。</p>
<p>##本來的Singleton<br>我們先複習一下一個基本的Singleton應該是長什麼樣子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Singleton &#123;</div><div class="line">private:</div><div class="line">    static Singleton* s_defInst;</div><div class="line">    Singleton() = delete;</div><div class="line">    Singleton&amp; Singleton(const Singleton&amp;) = delete;</div><div class="line">    Singleton&amp; operator=(const Singleton&amp;) = delete;</div><div class="line">   </div><div class="line">public:</div><div class="line">    //還記得為什麼是Singleton&amp;而不是Singleton*嗎?</div><div class="line">    static Singleton&amp; getInst() &#123;</div><div class="line">        if(s_defInst == nullptr)</div><div class="line">            s_defInst = new Singleton();</div><div class="line">        return *s_defInst;	</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void methodA();</div><div class="line">    RTValue methodB();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>所以，我們使用Singleton的時候看起來會像是這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Singleton::getInst().methodA();</div></pre></td></tr></table></figure></p>
<p>##我們希望這個Singleton能怎樣呢<br>目前來說，所以我們會希望有一個東西可以傳回一個「thread safe」的handle，這東西完全跟拿::getInst()擁有完全相同的界面，唯一的不同就是他會「排程」丟進Singleton讓他去一個個的做，或者讓它可以「僅鎖定共用資料，但是不會lock thread local」的方法來跑。</p>
<p>所以我們現在至少可以看出這東西會幾個Policy : </p>
<pre><code>1. 我們要能選擇multi thread的「策略」，可以讓他queue，也可以讓他選擇regular，甚至可以指定thread pool
2. 我們要能選擇single的生成方法以及原則(其實這不就是Modern C++ Design第一章的例子嗎)
3. 如果可能的話，Singleton自己有一個骨架，而實作跟界面要能當作Policy傳進來。
</code></pre><p>而讓他看起來應該至少要像是這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ISingletonMethods* s = Singleton::getProxy();</div></pre></td></tr></table></figure></p>
<p>或者更進一步，我們應該要有能力選擇要得到一個blocked或者non-blocked的proxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ISingletonMethods* blocked = Singleton::getProxy&lt;blocked&gt;();</div><div class="line">ISingletonMethods* unblocked = Singleton::getProxy&lt;unblocked&gt;();</div><div class="line"></div><div class="line">//blocked就像普通Singleton，會block自己的這個thread在得到結果</div><div class="line">blocked-&gt;methodA();</div><div class="line"></div><div class="line">//unblocked會讓你直接回傳...雖然我們現在還沒想到要怎麼傳比較漂亮</div><div class="line">//但是沒關係，我們後面會想到方法的 XD</div><div class="line">boost::tuple&lt;int, IRetNotifyHandle&gt; ret = unblocked-&gt;methodA();</div></pre></td></tr></table></figure></p>
<p>##「提供功能的界面以及實作」<br>很明顯的，如果要讓getProxy()跟getInst()一樣的功能的話，他們必須要有一個共通的界面才可以。當然，爽的話寫死也不會有什麼問題，但是我想這不是一個好的coder該做的事情 =P</p>
<p>假設，我們現在有兩個method，分別是<code>void methodA();</code>跟<code>RetValue methodB();</code>，那很明顯我們將會需要一個界面來宣告這個，兩個實作這個<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class ISingletonMethod &#123;</div><div class="line">    public:</div><div class="line">    void methodA() = 0;</div><div class="line">    RetValue methodB() = 0;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class SingletonMethodImpl : public ISingletonMethod &#123;</div><div class="line">    public:</div><div class="line">    void methodA() &#123; printf(&quot;This is methodA Impl!&quot;); &#125;</div><div class="line">    RetValue methodB &#123; return RetValue(); &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class SingletonMethodProxy : public ISingletonMethod &#123;</div><div class="line">    public:</div><div class="line">    void methodA() &#123; /*還沒有能決定這邊要queue呢 還是thread呢*/ &#125;</div><div class="line">    RetValue methodB() &#123; /*這邊更麻煩，我們甚至還不知道該怎麼拿ret value*/ &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>##決定multi thread策略的Proxy<br>現在我們有界面了，我們也定義出來這些東西了，所以我們可以讓Singleton看起來像是這樣 – 目前來講，我們恐怕只能讓<code>getProxy()</code>傳回指標，這有點尷尬呢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyInterface, typename _TyImpl&gt;</div><div class="line">class Singleton : public _TyImpl &#123;</div><div class="line">private:</div><div class="line">    static Singleton* s_defInst;</div><div class="line">    Singleton() = delete;</div><div class="line">    Singleton&amp; Singleton(const Singleton&amp;) = delete;</div><div class="line">    Singleton&amp; operator=(const Singleton&amp;) = delete;</div><div class="line">   </div><div class="line">public:</div><div class="line">    //還記得為什麼是Singleton&amp;而不是Singleton*嗎?</div><div class="line">    static Singleton&amp; getInst() &#123;</div><div class="line">        if(s_defInst == nullptr)</div><div class="line">            s_defInst = new Singleton();</div><div class="line">        return *s_defInst;	</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    static _TyInterface* getProxy() &#123;</div><div class="line">       /*看來我們的主戰場就在這裡了。*/</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //這兩個沒了，改用繼承的方式繼承過來</div><div class="line">    //void methodA();</div><div class="line">    //RTValue methodB();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>這Proxy該怎麼寫呢？目前來看，Proxy至少要能做到轉發給impl，所以這別無選擇，一定不是繼承，而是template。我們先寫一個什麼都不做的Proxy試試看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyInterface, typename _TyImpl&gt;</div><div class="line">class Proxy : public _TyInterface &#123;</div><div class="line">/*糟糕 中間要轉發一狗票_TyInterface的東西該怎麼寫？*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>很明顯，這種寫法會卡在Proxy無法正確的在編譯期產生正確的Proxy實作。我們可能會希望Proxy「經由某個管理步驟」以後完美的轉發給實作，看起來template展開後會很像是這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class SingletonMethodProxy : public ISingleton &#123;</div><div class="line">	SingletonMethodImpl _impl;</div><div class="line">  void methodA() &#123; doSomething(); _impl-&gt;methodA(); &#125;</div><div class="line">  RetValue methodB() &#123;doSomething(); return _impl-&gt;methodB(); &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>問題來了，methodA(), methodB()的Proxy實作我們無法順利地在template裡面轉發給_impl，使用者沒辦法如同呼叫Singleton::getInst().methodA()般的對Proxy做一樣的事情。</p>
<p>這個問題其實困擾了我一陣子，不過後來發現這可以經由override <code>operator-&gt;()</code>跟<code>operator.()</code>來解決一部份，這個code看起來會很像下面這樣…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt;</div><div class="line">class Proxy : public _TyImpl &#123;</div><div class="line">private:</div><div class="line">    _TyImpl&amp; _impl;</div><div class="line">    void doSomething();</div><div class="line">public:</div><div class="line">    Proxy(_TyImpl&amp; impl) : _impl(_TyImpl) &#123; &#125;</div><div class="line">    _TyImpl&amp; operator.() &#123; doSomething(); return _impl; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>這看起來很ok 但是有個問題：operator.是不被允許overload的，我們必須要overload operator-&gt;。overload operator-&gt;會產生另外一個很有趣（但是還算可以接受的）問題，我們先看看整個proxy應該要長什麼樣子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt;</div><div class="line">class Proxy &#123;</div><div class="line">	_TyImpl* _impl;</div><div class="line">	void doSomething() &#123; cout &lt;&lt; &quot;DoSomething&quot; &lt;&lt; endl; &#125;</div><div class="line">	public:</div><div class="line">	Proxy(_TyImpl* impl = nullptr) : _impl(impl) &#123;</div><div class="line">		if(_impl == nullptr)</div><div class="line">			_impl = new _TyImpl();</div><div class="line">	&#125;</div><div class="line">	_TyImpl* operator-&gt;() &#123; doSomething(); return _impl; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>這會產生一個問題，就是這做法其實相當不直覺，有點像smart pointer的做法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Proxy&lt;SingletonMethodImpl&gt;* proxy1 = new Proxy&lt;SingletonMethodImpl&gt;;</div><div class="line">proxy1-&gt;methodA(); //compile time error!</div><div class="line">(*proxy1)-&gt;methodA(); //ok, but WTF??</div><div class="line"></div><div class="line">Proxy&lt;SingletonMethodImpl&gt; proxy2;</div><div class="line">proxy2-&gt;methodA(); //ok, pass, 但是真的很不直覺，很像smart pointer的做法。、</div></pre></td></tr></table></figure></p>
<p>暫時解決了轉發的問題以後，現在要開始解決最難纏的排程的問題。這個其實可以借由Lambda相當清楚地解決一部份，不過仍然相當的抽象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt;</div><div class="line">_TyImpl* Proxy&lt;_TyImpl&gt;::operator-&gt;() &#123;</div><div class="line">    /*所以我們這邊要做什麼來排程呢？*/</div><div class="line">    return _impl; //這邊都把處理權交出去了....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，很明顯的我們不可能直接return _impl了，我們必須要回一個proxy(proxy裡面的proxy，有沒有那麼拗口？)，這個proxy的proxy需要能被cast成_TyImpl，所以大概會長這樣<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">template&lt;typename _TyImpl&gt; </div><div class="line">class PProxy &#123;</div><div class="line">	operator _TyImpl*();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/26/the-path-to-scheduled-process-singleton/" data-id="cj3b76vnv0005hzsio6p82jvo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-explicit-protocols" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/19/explicit-protocols/" class="article-date">
  <time datetime="2013-12-18T19:12:00.000Z" itemprop="datePublished">2013-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/19/explicit-protocols/">Implicit Protocols</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Implicit protocols, which is hint by its own name, is a protocol that “Other would not know”, and it is a bad design in most cases.</p>
<p>Let us start from a simple example :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">IService getService(String serviceName) &#123;</div><div class="line">	String[] args = serviceName.spilt(&apos; &apos;);</div><div class="line">	if(args.length == 1) //without any arguments</div><div class="line">		return targetService;</div><div class="line">    </div><div class="line">	if(args[1].equalsIgnoreCase(&quot;nonshared&quot;)</div><div class="line"> 		return createServiceFromClassName(serviceName);</div><div class="line">  </div><div class="line">  return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>This is a very bad design. We can guess the intentation from source code, for example, if the service name is “IOService” : we can get the IOService from <figure class="highlight plain"><figcaption><span>but if we want to have new instance other then the existed one, we should get this service as ```getService("IOService nonshared");```.</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">We **implicitly** uses the service name as a totally non-related usage. Even with documents, we should not do this because it will insanely increase the complexity of maintaining, and how do others know this? by looking into source code coincidentally observed this usage by others? no, it **NOT** makes sense, avoid this.</div><div class="line"></div><div class="line">Some implicit protocol comes with another name : *Convension*</div><div class="line"></div><div class="line">There is a perfect example in Java. We usually use ```~``` as representive of **Home Dictionary**, so it would come like this code :</div></pre></td></tr></table></figure></p>
<p>File file = new File(“~/Desktop/example.txt”);<br>file.mkdirs();<br>```</p>
<p>You would never find your file under the “~/Desktop” where it is expected, instead, you can guess where it goes :).</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/19/explicit-protocols/" data-id="cj3b76vnr0004hzsi9cyyml1s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-visual-studio-online" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/03/visual-studio-online/" class="article-date">
  <time datetime="2013-12-03T05:23:00.000Z" itemprop="datePublished">2013-12-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/03/visual-studio-online/">Visual Studio Online</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.windowsazure.com/zh-tw/pricing/details/visual-studio-online/" target="_blank" rel="external">Visual Studio Online</a>我到了剛剛才搞懂那是啥東西 囧</p>
<p>簡單的說，這並不是一個<strong>“基於HTML5，以及網頁技術，可以讓你只要開瀏覽器就能管理編輯專案”</strong>的東西，而是比較類似GitHub(同時他的主要對手也是GitHub, 嗚呼)，而且比GitHub更加深入的整合的一個雲端專案代管系統。他比GitHub高檔的地方在於他同時結合了CI(不過看起來要價不少)以及與Visual Studio無縫的整合(這聽起來好像廢話)，甚至提供了Eclipse Plugin讓你可以不用Visual Studio也能協同開發。這服務是Windows Azure的一部分，所以可以跟現有的Windows Azure Credit Quota共用。</p>
<p>有點我倒是想說，昨天我才註冊了上去，今天就有小姐打電話來問了，這一天是想問出什麼使用感想阿 XD。另外…MSTW用的節費電話(看號碼應該是Skype?)品質實在堪慮，這樣的客服電話讓客人聽一句漏兩句是不行的 囧興</p>
<p>價格可以參考我剛post的pricing，不過我待過的幾家公司似乎只有一家用Visual Studio當solution，以coder的世界來講，除非是.net開發者，不然這東西看起來似乎不是很討好阿(遠目)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/03/visual-studio-online/" data-id="cj3b76vno0002hzsiujfrasug" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-this-is-singleton" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/08/07/this-is-singleton/" class="article-date">
  <time datetime="2013-08-06T18:29:00.000Z" itemprop="datePublished">2013-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/08/07/this-is-singleton/">This is SINGLETON!</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Singleton…</p>
<p>說真的，這可能可以榮登史上最常見被濫用的Pattern，沒有之一。它本身撰寫並不困難，使用直覺（只是使用上實在又臭又長了一點），在C++裡面就更簡單了，隨便一個class套個<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>class Balabala {<br>    public:<br>        void doSomething();<br>};<br>typedef Loki::SingletonHolder<balabala> SingleBala;</balabala></p>
<p>void test() {<br>    SingleBala::instance().doSomething();<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">甚至要撰寫一個最基本的Singleton也是簡單到爆炸</div></pre></td></tr></table></figure></p>
<p>class Balabala {<br>    private:<br>        static Balabala* defInst;<br>    public:<br>        static inline Balabala&amp; instance() {<br>            if(defInst == null)<br>                defInst = new Balabala();</p>
<pre><code>    return *defInst;
}
</code></pre><p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">當然，Loki的SingletonHolder裡面做了很多有趣的事情，有興趣的人請自己參考一下[這裡](http://sourcecodebrowser.com/asc/1.16.3.0/_singleton_8h_source.html)。當然，請先稍微念一下Modern C++ Design，不然可能連第一個開頭宣告的```CreationPolicy```都不知道是幹嘛的。不過，即使是很初步的大略看了一下，都看得出來Andrei Alexandrescu在設計這個東西的時候，考慮了生命週期以及保留了其他new/delete方法選擇上的彈性。</div><div class="line"></div><div class="line">事實上，也由於```Loki::SingletonHolder&lt;T&gt;```的關係，這個東西在許多系統裡面被濫用到一種莫名其妙的地步， ***幾乎所有希望能夠被在全域存取的物件*** 都會有人想把它寫成Singleton。更糟糕的是，如果你試圖阻止他的話，他會用更糟的static或者毫無章法的在precompiled header內extern去做這種行為。</div></pre></td></tr></table></figure></p>
<p>//in Precompile.pch<br>extern SingleFooService FOO;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">![](https://dl.dropboxusercontent.com/u/3992354/double_facepalm.jpg)</div><div class="line"></div><div class="line">所以，當你有足夠的知識去判斷 ***「這個不該用Singleton」*** 的時候，請很明確地順便跟他說這東西 ***「不該被在不受控管的情況下全域存取」*** ，甚至 ***「根本不該做成全域存取，應該以參考的方式傳入」*** 。很多時候，明明只需要一個String，可是因為貪圖方便不去改member function，直接在裡面呼叫衛星砲Singleton把String傳下來，結果就是把相依性搞得亂七八糟。</div><div class="line"></div><div class="line">有個作者(可以google一下WashuHibiki)做了一個一針見血的評論 : *Not really, most of the use cases for singletons revolve around: &quot;I want to access X, but its not &apos;OO&apos; to use a global, so I&apos;ll dress it up in a class and call it &apos;OO&apos;!&quot;.* 「恩..大多數的Singleton的使用情況，都是在於『我要要存取X，但是使用全域實在不是OO的風格，所以我把X給變裝裝在一個class下，這就是OO了!』」</div><div class="line"></div><div class="line">Singleton的優點我想應該不用說太多，每個人用Singleton一定都是因為他有優勢所以才會去用他。可是，Singleton有很多侷限，很多人卻對這些侷限一無所知而照樣用下去。Singleton有幾個比較明顯的缺點</div><div class="line"></div><div class="line">- 它會讓整個相依性爛成一鍋粥。</div><div class="line">- 它由於本身特性使然，使的它一旦被使用下去就很難去擴充。一旦決策錯誤，大多數的Singleton設計上都很難讓人補救。</div><div class="line">- 也是由於它本身特性使然，它對於threading的處理有很多潛在的問題，尤其是當它有context的時候。</div><div class="line">- 它在很多情況下沒辦法掌握先後順序。舉個最簡單的例子，假設它需要init，而你在foo::instance()的當下壓根不知道她有沒有被init過，你得做個旗標去控制它。然而，並不是所有的地方都可以讓Singleton有正確的context做init的。</div><div class="line"></div><div class="line">這些缺點都是在他被 ***正確*** 使用的時候會碰到的問題，更不用講它被 ***不正確*** 使用的時候會有多少問題。```Loki::SingletonHolder&lt;class&gt;```實在是方便到爆炸，以至於大家什麼class都想往裡面包。我來舉幾個我看過的慘劇</div><div class="line"></div><div class="line">- 某人先宣告了一個```typedef Loki::SingletonHolder&lt;FOO&gt; singleFoo;``` 另外一個人在不同的.h裡面宣告了```typedef Loki::SingletonHolder&lt;FOO&gt; fooSingle```，然後某人開始抱怨為什麼singleFoo會自己改東西，明明沒有code呼叫他</div><div class="line">- 某些情況下的```singleFoo::instance().xxx()```會炸掉，問題幾乎無法重現。後來才發現炸掉的沒有```.init()```，而他一點把握都沒有到底在系統的什麼地方對他作```singleFoo::instance().init(context)```才能正確的把singleFoo init起來，因為他根本沒把握哪個地方會是第一次執行singleFoo的地方。</div><div class="line">- 這個比較偏向於笑話，有人把有state的class包成singleton，比方說DX的```beginDraw()```, ```endDraw()```, 你很多操作一定要放在這兩者之間....可以想想有stack一路call下去會怎樣</div><div class="line">- 這也是個笑話，設計不良的singleton跑在multi thread環境下debug一個難以重現的錯誤debug了一個月</div><div class="line"></div><div class="line">其實先撇掉這些令人噴飯的使用例子，其實大多數Singleton都有一些小撇步來避開這些問題。通常來講，我們要有一個認知： ***Singleton就是Global，不要再催眠自己它不是不是Global了!*** Global的缺點Singleton一個都不會少，我們要用Global的方法去思考這些東西的必要性。</div><div class="line"></div><div class="line">首先，我們要盡量降低Singleton的數量。最簡單的方式就是讓系統整個Singleton剩下一個。比方說我們可能有以下的範例</div></pre></td></tr></table></figure></p>
<p>typedef Loki::SingletonHolder<txmanager> SingleTxManager;<br>typedef Loki::SingletonHolder<bandmanager> SingleBandManager;<br>typedef Loki::SingletonHolder<channelmanager> SingleChannelManager;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我們只允許系統存在一個Singleton，稱為SystemManager</div></pre></td></tr></table></figure></channelmanager></bandmanager></txmanager></p>
<p>class SystemManager {<br>private:<br>    TxManager<em> mTxManager;<br>    BandManager</em> mBandManager;<br>    ChannelManager<em> mChannelManager;<br>public:<br>    TxManager</em> getTxManager();<br>    BandManager<em> getBandManager();<br>    ChannelManager</em> getChannelManager();<br>};</p>
<p>typedef Loki::SingletonHolder<systemmanager> SingleSystem;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">這是最簡單的一步，而且優點非常的明顯。其中一個很明顯的地方在於，當系統需要第二組TxManager的時候，第一種做法會讓整個系統毫無辦法的只能整個大改，但是第二種做法卻可以這樣做</div></pre></td></tr></table></figure></systemmanager></p>
<p>enum TxMgrType {<br>    TX_ORIGINAL,<br>    TX_EXTENDED<br>};</p>
<p>TxManager* getTxManager(TxMgrType type = TX_ORIGINAL);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">這樣就可以輕易的轉換過去，沒有參數的getTxManager會拿到原來的，有傳入TX_EXTENDED的則可以拿到新的。當然，這只是個緩衝跟拖時間的方法，趕快把系統過渡到有兩個TxManager的語法吧... 而且，SystemManager基本上需要考慮的threading issue可以降到最低，因為整個System的Context看起來都是init以後就可以frozen，所以整個系統設計起來將會非常簡單。最後，我們可以比較簡單地找到一個地方去把所有的class初始化。</div><div class="line"></div><div class="line">Singleton的Threading issue也是一個常常被討論的話題。因為這東西被存取的地方實在太多，可能性也太過於頻繁，所以我們必須用許許多多的mutex把很多部分給保護住。但是就有如所有的Semaphore-like的保護一樣，這東西會造成相當程度的設計問題以及死結。所以，為了因應這種問題，我們通常來講會在一些已知的高Threading issue Singleton做一些手腳，比方說把所有的context parameter分開等等...</div></pre></td></tr></table></figure></p>
<p>class FooService {<br>private:<br>    typedef void(<em>FOO_CALLBACK)(void</em>);<br>    const int MAX_WORKING_THREAD = 20;<br>    boost::threadpool::pool s_ThreadPool(MAX_WORKING_THREAD);<br>public:<br>    int doSomething(FOO_CALLBACK callback);<br>};</p>
<p>typedef Loki::SingletonHolder<fooservice> SingleFooService;<br>```</fooservice></p>
<p>簡單的說，我們直接把Thread的事情自己收進來管理，再由一個Callback來把結果傳回去。Java在後期引進了一個概念叫做<a href="http://openhome.cc/Gossip/JavaGossip-V2/CallableFuture.htm" target="_blank" rel="external">Future</a>, <a href="http://www.boost.org/doc/libs/1_46_0/boost/thread/future.hpp" target="_blank" rel="external">C++也有</a>，這個對Threading設計算是非常重要的一個概念，可以大幅減化這方面的設計（也就是讓Singleton傳回一個boost::future，你需要的時候再跑起來就好）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/08/07/this-is-singleton/" data-id="cj3b76vnq0003hzsizft4sphf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-suddenly-thought-of-that-old-joke" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/07/18/suddenly-thought-of-that-old-joke/" class="article-date">
  <time datetime="2013-07-18T00:13:00.000Z" itemprop="datePublished">2013-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/18/suddenly-thought-of-that-old-joke/">突然想到這個老掉牙的笑話</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>某天差點被自己害死</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sid = setsid();</div><div class="line">printf(&quot;Starting daemon, sid = %d\n&quot;, sid);</div><div class="line"></div><div class="line">printf(&quot;Disabling each standard file pipes... \n&quot;);</div><div class="line">int FilePipe[3] = &#123;STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO&#125;;</div><div class="line">for(int i = 0; i &lt; sizeof(FilePipe)/sizeof(int); ++i)</div><div class="line">	close(FilePipe[i]);</div><div class="line">printf(&quot;Done\n&quot;);</div></pre></td></tr></table></figure>
<p>恩….誰看出問題在哪了？單單從log上看看起來很像是這個for loop永遠跑不完 XD</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/07/18/suddenly-thought-of-that-old-joke/" data-id="cj3b76vna0000hzsipnovas69" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-talk-about-service-design" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/07/17/talk-about-service-design/" class="article-date">
  <time datetime="2013-07-17T00:52:00.000Z" itemprop="datePublished">2013-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/07/17/talk-about-service-design/">來聊聊Service的設計上的一個Technique吧!</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我們在一個大型系統裡面，常常會用到許多Service，這些Service通常來講會以Singleton的形式存在（或者他的變形，比方說在Spring裡面就是@Autowire）。這些系統用的Service通常會有一個共通的界面，比方說，這些Service都是CRUD服務的話，大概會長這樣…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">interface IService &#123;</div><div class="line">	String getServiceName();</div><div class="line">	String getServiceID();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface ICRUDService&lt;Target&gt; extends IService &#123;</div><div class="line">	long create(Target t) throw ServiceException;</div><div class="line">	T read(long uuid) throw ServiceException;</div><div class="line">	long update(Target t) throw ServiceException;</div><div class="line">	bool delete(long uuid) throw ServiceException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>淺顯易懂沒有任何問題。假設我們有一個Service叫做NameCard service，我們可能就會這樣實作…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class NameCardService implements ICRUDService&lt;NameCard&gt; &#123;</div><div class="line">	// ICRUDService implementation is here</div><div class="line">	…</div><div class="line">	…</div><div class="line">	…</div><div class="line">	</div><div class="line">	//NameCardService only public method</div><div class="line">	public void sort();</div><div class="line">	public List&lt;NameCard&gt; getDuplicated();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>當我們需要取用這個服務的時候，有很多種不同的做法。最普通的Singleton風格就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NameCardService service = NameCardService.getInst();</div></pre></td></tr></table></figure>
<p>而Spring風格則會是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Autowire</div><div class="line">NameCardService service;</div></pre></td></tr></table></figure>
<p>而Android風格則會是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NameCardService service = (NameCardService)context.getSystemService(NAME_CARD_SERVICE);</div></pre></td></tr></table></figure>
<p>前兩者其實都沒什麼型別安全上的問題，第一個做法會有Scaling上的問題，我們必須要在getInst()裡面檢查太多東西（別忘了，getInst()是static，沒辦法被包進interface – 這點顯然obj-c是好一點），比方說有沒有權限拿取啊，該做哪些logging阿….balabalaba，這些通通都是duplicated code – 因為他們沒辦法被寫入interface。第二種作法則是綁死在Spring，而且我想應該不用我說，大家也知道Spring新增一個服務並沒有那麼簡單直觀。</p>
<p>所以Android選擇了3，但是很明顯地，這邊存在一個無法在編譯期檢查出來的型別問題，也就是說，你可能無法阻止別人寫成這樣(注意getSystemService傳進去的參數)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NameCardService service = (NameCardService)context.getSystemService(TELEPHONY_SERVICE);</div></pre></td></tr></table></figure>
<p>因為它getSystemService傳回來的是一個類似IService的東西，這等於要強迫使用者使用「正確的Context」「正確的Service Handle」去轉型成「正確的Service」</p>
<p>以一個寫Framework的人來講，這真是惡夢 - 誰曉得Framework user這些工程師會不會拿一些莫名其妙的錯用來當作bug開給你？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//以下當然會執行期爆掉</div><div class="line">((NameCardService)context.getSystemService(TELEPHONY_SERVICE)).sort();</div><div class="line"></div><div class="line">//我必須對某些喜歡這種懶人寫法的人致敬，這些人專注於寫出讓人（包含自己）看不懂的code的努力，實在是令人太欽佩了。</div></pre></td></tr></table></figure>
<p>重點在於Java來講，用任何一個Native型別去當作Handle都是一種頗令人困惑而且不智的行為。什麼是Handle？其實就相當於map裡面的key，用這個key去取得value(在這裡就是指Service)。有興趣的人可以看看Android的getSystemService(…)裡面傳入的參數是什麼？結論會很讓你噴飯，他傳入的Handle索引居然是一個字串…不過這有他的道理，他傳入的字串是一組class的qualified name，這可以讓他很輕易地「無中生有」出一組service – 我們不在這裡討論這種規格外的做法。另外，傳入string還有一個非常糟糕的用途–它可以把要傳給service的參數包在一部分的String傳進去，很方便，很好用，我們也可以想像這是維護上的多大的災難。</p>
<p>比方說這類型的災難</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">OMGWTF omg = (OMGWTF)context.getSystemService(&quot;OMGWTF Service! 隔壁老王是變態，小明是笨蛋，初始化的時候順便幫我買兩斤三星蔥!&quot;);</div><div class="line"></div><div class="line">//簡單說，就是拿字串當protocol...這種天才我職業生涯碰過好幾次，非常的天才，非常的創意無限，非常的奔放</div></pre></td></tr></table></figure>
<p>有沒有什麼方法至少可以逼使用者不用轉型，甚至在編輯器裡面就可以輕鬆地幫你指出你拿到的是什麼Service而不會出錯呢？比方說我們能不能在編譯時期就檢查出下面這寫法對不對</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//拿出來就是NameCardService，不需要轉型</div><div class="line">BaseCRUDService.getService(???????????).sort();</div><div class="line">//拿出來就是Telephony Service，不需要轉型</div><div class="line">BaseCRUDService.getService(???????????).getTeleponyStatus();</div></pre></td></tr></table></figure>
<p>甚至Eclipse就可以幫你檢查出來了!這乾五可能!?</p>
<p><strong>廢話，當然可以，不然我寫這篇幹嘛 XD</strong> </p>
<p>這秘密在於我們Handle的選擇。String?這顯然不對，long?這當然也不行，特殊規格的class?我沒想到要怎麼用這種方法，也許誰來發明一下</p>
<p><strong>我們Handle選用的是Java Generic可以直接支援的Class&lt;?&gt;</strong></p>
<p>老實講我一直覺得Java Generic雖然靈活度不比C++的Template，不過Generic裡面的”?”實在是一個很無賴的東西，它可以做出很多平常根本想當想不到的方法。</p>
<p>首先，我們為了讓所有的CRUD Service都會「註冊自己」，讓自己可以被CURDService找到，所以我們必須要有一個「所有的CRUDService都會跑得到的地方」–我們當然第一個想到的就是constructor，所以我們要讓所有的CRUD Service從implements ICRUDService改成extend BaseCRUDService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">abstract class BaseCRUDService&lt;T&gt; implements ICRUDService&lt;T&gt; &#123;</div><div class="line">	BaseCRUDService() &#123;</div><div class="line">	//現在我們有一個地方可以讓所有的CRUD Service都跑到了</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class NameCardService extends BaseCRUDService&lt;NameCard&gt; &#123;</div><div class="line">…</div><div class="line">…</div><div class="line">…</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>這邊有一份實作，可以先給大家參考一下，出來差不多就是我剛剛講的結果。所有的Service只要繼承BaseCRUDService，就可以用BaseCRUDService.getService(Class&lt;? extends BaseCRUDService&gt; clz);拿出正確的Service，而且可以直接編譯期判斷出該型別，並且可以用編譯器的自動完成去呼叫該Service獨有的method。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import java.util.HashMap;</div><div class="line"></div><div class="line">public abstract class BaseCRUDService&lt;MarshelBean extends ICRUDBean&gt; implements ICRUDService&lt;MarshelBean&gt; &#123;</div><div class="line">	</div><div class="line">	protected BaseCRUDService() &#123;</div><div class="line">		registerSelf(this);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@SuppressWarnings(&#123; &quot;unchecked&quot; &#125;)</div><div class="line">	private &lt;T extends ICRUDService&lt;?&gt;&gt; void registerSelf(T service) &#123;</div><div class="line">		serviceMap.put( (Class&lt;? extends ICRUDService&lt;?&gt;&gt;) service.getClass(), service);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	/**</div><div class="line">	 * For thread safety, it can be ConcurrentHashMap...as long as I don&apos;t think it is needed.</div><div class="line">	 * Since it is single thread write one time only, HashMap can be good enough in any case.</div><div class="line">	 */</div><div class="line">	static HashMap&lt;Class&lt;? extends ICRUDService&lt;?&gt;&gt;, ICRUDService&lt;?&gt;&gt; serviceMap = new HashMap&lt;Class&lt;? extends ICRUDService&lt;?&gt;&gt;, ICRUDService&lt;?&gt;&gt;();</div><div class="line">	</div><div class="line">	@SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">	static public &lt;T extends ICRUDService&lt;?&gt; &gt; T getService(Class&lt;T&gt; targetService) &#123;</div><div class="line">		return (T) serviceMap.get(targetService);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>這份實作神奇的地方在於，只要任何服務繼承它，那它就可以被 <strong>「型別安全的」</strong> 取出來。這點很重要，請跟著我重複念兩次。另外，這份實作是取自於我自己寫的一個PP通訊界面，所有CRUD都會至少有一個Marshel(管理)的對象，這個被管理的對象一定會繼承自IBean，如果你不知道他是幹嘛的，請完全不用理他。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class PeopleRecordService extends BaseCRUDService&lt;PeopleRecord&gt; &#123;</div><div class="line">…</div><div class="line">…</div><div class="line">…</div><div class="line"></div><div class="line">	void people_record_only_function();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class CarRecordService extends  BaseCRUDService&lt;CarRecord&gt; &#123;</div><div class="line">…</div><div class="line">…</div><div class="line">…</div><div class="line">	void car_record_only_function();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好，我們把這個東西setup了，該試試看他的威力了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//PASS!</div><div class="line">BaseCRUDService.getService(PeopleRecordService.class).people_record_only_function();</div><div class="line"></div><div class="line">//Compile Time error!</div><div class="line">BaseCRUDService.getService(PeopleRecordService.class).car_record_only_function();</div><div class="line"></div><div class="line">//或著試試看下面這邊自動完成會幫你秀出什麼東西？</div><div class="line">BaseCRUDService.getService(CarRecordService.class).;</div></pre></td></tr></table></figure>
<p>That’s it~ 沒有強制轉型，沒有奇怪的Context問題，更沒有duplicated static method，世界真是美好…</p>
<p>當然，接下來我們當然要仔細看看為什麼要這樣設計了。這些設計其實都很簡單（甚至沒有偷瞄其他專案，因為我還沒看過其他人這樣寫）。首先，我們會希望有一個地方能夠索引到所有的Service，不然getService()要找誰要Service去？（就算是Spring也是從xml裡面取出qualified name去invoke…我的媽，我很討厭這種做法 囧，我們不能把它靜態的存起來嗎？），我們乾脆直接使用CRUDService的中繼界面（以這邊的例子來講就是BaseCRUDService）來放這張表。以中繼界面來放這張表還有一個好處，就是Register也可以寫在這裡，這樣就有一個constructor可以讓所有的CRUDService有個共通執行的地方–把自己註冊上去。</p>
<p>不過這語法看起來真是恐怖，我們把它拆解過來看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static HashMap&lt;Class&lt;? extends ICRUDService&lt;?&gt;&gt;, ICRUDService&lt;?&gt;&gt; serviceMap = new HashMap&lt;Class&lt;? extends ICRUDService&lt;?&gt;&gt;, ICRUDService&lt;?&gt;&gt;();</div></pre></td></tr></table></figure>
<p>這HashMap我們把它放大來看的話，會發現他的key其實是一個<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">記住，要使用者工程師去寫這些是不好的，我們最好在背後就偷偷的把它做掉，比方說經由這種機制偷偷的把它註冊起來，下游使用者甚至不知道這回事，他們只要知道以後用```getService()```能拿到服務就好。下游工程師的小腦袋已經裝了太多的痛苦跟哀傷，我們要盡可能避免因為他沒時間看文件以至於少寫```registerSelf()```跑來把這種哀慟傳遞給我們（逃）</div><div class="line"></div><div class="line">所以我們現在就有一個型別檢查的serviceMap了，這東西會做一次基本的型別檢查，不管用得到用不到。它可以保證，進去的Class一定至少是個ICRUDService，而不是IGiveUp或者IDontCare</div><div class="line"></div><div class="line">接下來這Service拿出來的地方就很Tricky了，同樣的，語法上看不懂的請回去翻Java課本的Generic [^1]</div></pre></td></tr></table></figure></p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
static public &lt;T extends ICRUDService&lt;?&gt; &gt; T getService(Class&lt;T&gt; targetService) {
    return (T) serviceMap.get(targetService);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">Generic傳回型別基本上可以保證它傳回的值一定是個ICRUDService，不過看起來好像沒上面提到的那麼神奇？不，這個傳回值其實是由getService裡面的```Class&lt;T&gt; targetService```幫我們定案的，前者只是幫我們把T限定在ICRUDService而以，後者才是幫我們真正決定T到底要是什麼。假設我們targetService在編譯期就指定了PersonRecordService.class，那這樣不就足以逼他傳回PersonRecordService的物件了嗎？上面的自動完成居然是被這樣hint出來的，該說Eclipse好聰明嗎 XD</div><div class="line"></div><div class="line">哎呀，真難得Generic居然可以勉強做到跟C++的Template一樣神奇的了（也許還更神奇點，因為C++ template甚至沒辦法在pre-compile做這些檢查，他必須要等compile後把template真正實體化出來才能開始做很多事情--包括印出一堆讓人看不懂的error訊息在內）</div><div class="line"></div><div class="line">當然這東西並不是真正的skip掉轉型，看那堆```@SupressWarnings(&quot;unchecked&quot;)```就知道其實我們只是讓使用者不准自己轉而以，我們可以幫他們轉好以後丟出去(老實講，跟Android拿service的方式比起來，我真的覺得這種做法有著巨大的好處，當然Android有他自己的理由)。使用者在用的時候只需要把正確的.class當handle丟進去，```getService()```就會吐出已經幫你轉好，而且不會有任何錯誤的Service。</div><div class="line"></div><div class="line">C++有很類似的作法，而且有更明顯的好處 -- 我們可以在系統裡面偷偷用```static_cast&lt;&gt;```幫使用者轉，而不是讓使用者自己冒著風險去轉，或者謹慎的使用者使用更耗費資源的```dynamic_cast&lt;&gt;```去轉 -- 以java來講，就是拿回來的Service還得用instanceof關鍵字去檢查，沒這必要! 我們幫使用者做好這些事情就好。</div><div class="line"></div><div class="line">最後我們提供一個乾淨的，可以馬上執行的範例，讓大家玩玩看。</div></pre></td></tr></table></figure>
<p>package com.rayer.service.example;</p>
<p>import java.util.HashMap;<br>import java.util.Map;</p>
<p>interface IService {<br>    void this_interface_is_not_really_important();<br>}</p>
<p>class ServiceBase implements IService {</p>
<pre><code>public void this_interface_is_not_really_important() {
    System.out.println(&quot;Not important at all!&quot;);

}

protected ServiceBase() {
    registerSelf();
}

private void registerSelf() {
    ServiceBase.register(this);
}

//Static method and fields

private static Map&lt;Class&lt;? extends IService&gt;, IService&gt; serviceMap = new HashMap&lt;Class&lt;? extends IService&gt;, IService&gt;();

static private void register(IService service) {
    serviceMap.put( (Class&lt;? extends IService&gt;) service.getClass(), service);
}

@SuppressWarnings(&quot;unchecked&quot;)
static public &lt;T extends IService&gt; T getService(Class&lt;T&gt; clazz) {
    return (T)serviceMap.get(clazz);
}
</code></pre><p>}</p>
<p>class AService extends ServiceBase {<br>    public void service_A_only_method() {<br>        System.out.println(“Service A!”);<br>    }<br>}</p>
<p>class BService extends ServiceBase {<br>    public void service_B_only_method() {<br>        System.out.println(“Service B!”);<br>    }<br>}</p>
<p>class CService extends ServiceBase {<br>    public void service_C_only_method() {<br>        System.out.println(“Service C!”);<br>    }<br>}</p>
<p>public class Example {<br>    AService a = new AService();<br>    BService b = new BService();<br>    CService c = new CService();</p>
<pre><code>void main(String[] args) {
    ServiceBase.getService(AService.class).service_A_only_method();
    ServiceBase.getService(BService.class).service_B_only_method();
    //大家可以試試看 在下面打入
    //ServiceBase.getService(CService.class).
    //eclipse的自動完成會幫你完成什麼？

    IService if = ServiceBase.getService(AService.class); //OK!
    AService as = ServiceBase.getService(AService.class); //OK! 不用幫他轉型!
    BService bs = ServiceBase.getService(AService.class); //Compile time error! 幫你檢查好型別了!

}
</code></pre><p>}<br>```</p>
<p>其實這份實作對於Singleton Service來講，還是有許多需要改進跟保護的地方。比方說，事實上<code>new AService()</code>不是很必要，我們可以設計一下讓他在getService裡面，要是沒辦法取到AService instance的話幫他invoke一個起來，或者有個機制可以一口氣註冊invoke一次完成…不過關於Service完善設計可能要寫的code跟篇幅將會不亞於這篇，下次吧 XD</p>
<p>[^1]: 老實講，這種code看不懂似乎也是很正常，畢竟Generic很少有哪些範例會需要那麼複雜的前置宣告。就如同我以前曾經也說過，C++過於精美的template將會對<strong>正常</strong>水平的coder是一種過度的負擔。不過，武器工匠本來就該懂來福線要怎麼磨，普通使用者只要知道怎麼開槍就好，這種等級的library就交給該有相當等級的coder去維護吧，不需要太考慮「語法上的過難」這問題，不然STL就真的變成很糟的設計了，能維護的人實在太少。不過顯然大家都不會對STL有這種想法 XD</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/07/17/talk-about-service-design/" data-id="cj3b76vnh0001hzsi0xkwte7t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/09/how-to-use-cmake-with-git-to-easily-use-external-library/">如何利用CMake跟git來輕易的使用外部Library</a>
          </li>
        
          <li>
            <a href="/2017/02/13/python-trick-burst-attack-test/">Python Trick : Burst Attack Test</a>
          </li>
        
          <li>
            <a href="/2016/02/03/most-vexing-parsingc/">Most Vexing Parsing(C++)</a>
          </li>
        
          <li>
            <a href="/2015/08/23/markdown-text-color-support/">Markdown文字色彩支援</a>
          </li>
        
          <li>
            <a href="/2015/08/16/starry-sky/">Starry Sky</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>